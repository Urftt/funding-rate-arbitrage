---
phase: 04-historical-data-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/bot/data/__init__.py
  - src/bot/data/models.py
  - src/bot/data/database.py
  - src/bot/data/pair_selector.py
  - src/bot/config.py
  - src/bot/exchange/client.py
  - src/bot/exchange/bybit_client.py
  - pyproject.toml
autonomous: true

must_haves:
  truths:
    - "SQLite database can be created with all 4 tables (funding_rate_history, ohlcv_candles, fetch_state, tracked_pairs) plus schema_version"
    - "ExchangeClient has abstract methods for fetch_funding_rate_history and fetch_ohlcv"
    - "BybitClient implements both new methods using ccxt async"
    - "Top 20 USDT linear perpetual pairs can be selected from FundingRateData list by volume"
    - "HistoricalDataSettings configurable via HISTORICAL_ env prefix"
  artifacts:
    - path: "src/bot/data/__init__.py"
      provides: "Package exports"
    - path: "src/bot/data/models.py"
      provides: "HistoricalFundingRate and OHLCVCandle dataclasses"
      min_lines: 20
    - path: "src/bot/data/database.py"
      provides: "HistoricalDatabase async SQLite connection manager with schema creation"
      min_lines: 60
      exports: ["HistoricalDatabase"]
    - path: "src/bot/data/pair_selector.py"
      provides: "select_top_pairs function"
      exports: ["select_top_pairs"]
    - path: "src/bot/config.py"
      provides: "HistoricalDataSettings class"
      contains: "class HistoricalDataSettings"
    - path: "src/bot/exchange/client.py"
      provides: "fetch_funding_rate_history and fetch_ohlcv abstract methods"
      contains: "fetch_funding_rate_history"
    - path: "src/bot/exchange/bybit_client.py"
      provides: "Concrete implementations of historical data fetch methods"
      contains: "fetch_funding_rate_history"
    - path: "pyproject.toml"
      provides: "aiosqlite dependency"
      contains: "aiosqlite"
  key_links:
    - from: "src/bot/data/database.py"
      to: "aiosqlite"
      via: "import aiosqlite"
      pattern: "import aiosqlite"
    - from: "src/bot/data/models.py"
      to: "decimal.Decimal"
      via: "Decimal fields for precision"
      pattern: "Decimal"
    - from: "src/bot/exchange/bybit_client.py"
      to: "ccxt fetch_funding_rate_history"
      via: "self._exchange.fetch_funding_rate_history"
      pattern: "fetch_funding_rate_history"
---

<objective>
Create the foundational data layer for historical data persistence: data models, SQLite database manager, configuration, exchange client extensions for historical data endpoints, and the pair selector.

Purpose: Establish all the types, database schema, exchange API access, and configuration that the HistoricalDataStore (plan 02) and HistoricalDataFetcher (plan 02) will build on. Without these foundations, no data can be fetched or stored.

Output: New `src/bot/data/` package with models, database manager, and pair selector; extended ExchangeClient with historical fetch methods; HistoricalDataSettings in config; aiosqlite dependency added.
</objective>

<execution_context>
@/Users/luckleineschaars/.claude/get-shit-done/workflows/execute-plan.md
@/Users/luckleineschaars/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-historical-data-foundation/04-CONTEXT.md
@.planning/phases/04-historical-data-foundation/04-RESEARCH.md
@src/bot/config.py
@src/bot/models.py
@src/bot/exchange/client.py
@src/bot/exchange/bybit_client.py
@pyproject.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Data models, database manager, config, and pair selector</name>
  <files>
    src/bot/data/__init__.py
    src/bot/data/models.py
    src/bot/data/database.py
    src/bot/data/pair_selector.py
    src/bot/config.py
    pyproject.toml
  </files>
  <action>
1. Add `"aiosqlite>=0.22"` to `pyproject.toml` dependencies list. Run `pip install -e ".[dev]"` to install.

2. Create `src/bot/data/__init__.py` with exports for the data module's public API.

3. Create `src/bot/data/models.py` with two dataclasses:
   - `HistoricalFundingRate`: symbol (str), timestamp_ms (int), funding_rate (Decimal), interval_hours (int, default 8)
   - `OHLCVCandle`: symbol (str), timestamp_ms (int), open (Decimal), high (Decimal), low (Decimal), close (Decimal), volume (Decimal)
   - Use `Decimal` for all monetary values (project convention). Use `from dataclasses import dataclass`.

4. Create `src/bot/data/database.py` with class `HistoricalDatabase`:
   - Constructor takes `db_path: str = "data/historical.db"`
   - `async connect()`: Opens aiosqlite connection, sets `PRAGMA journal_mode=WAL` and `PRAGMA synchronous=NORMAL`, calls `_create_tables()`, checks/sets schema version
   - `async close()`: Closes the connection if open
   - `async _create_tables()`: Creates all 5 tables IF NOT EXISTS:
     - `schema_version` (version INTEGER PRIMARY KEY)
     - `funding_rate_history` (symbol TEXT NOT NULL, timestamp_ms INTEGER NOT NULL, funding_rate TEXT NOT NULL, interval_hours INTEGER NOT NULL DEFAULT 8, PRIMARY KEY (symbol, timestamp_ms))
     - `ohlcv_candles` (symbol TEXT NOT NULL, timestamp_ms INTEGER NOT NULL, open TEXT, high TEXT, low TEXT, close TEXT, volume TEXT, PRIMARY KEY (symbol, timestamp_ms))
     - `fetch_state` (symbol TEXT NOT NULL, data_type TEXT NOT NULL, earliest_ms INTEGER, latest_ms INTEGER, last_fetched_at INTEGER, PRIMARY KEY (symbol, data_type))
     - `tracked_pairs` (symbol TEXT PRIMARY KEY, added_at INTEGER NOT NULL, last_volume_24h TEXT, is_active INTEGER NOT NULL DEFAULT 1)
   - Create indexes: `idx_funding_symbol_ts` on funding_rate_history(symbol, timestamp_ms), `idx_ohlcv_symbol_ts` on ohlcv_candles(symbol, timestamp_ms)
   - Expose `self.db` property to access the raw aiosqlite.Connection (used by HistoricalDataStore in plan 02)
   - Use `async with` context manager support (`__aenter__`, `__aexit__`) for clean resource management
   - Store all decimal values as TEXT in SQLite to preserve Decimal precision (project convention)

5. Create `src/bot/data/pair_selector.py` with function `select_top_pairs(funding_rates: list[FundingRateData], count: int = 20) -> list[str]`:
   - Import `FundingRateData` from `bot.models`
   - Filter to USDT perpetuals only: `fr.symbol.endswith(":USDT")`
   - Sort by `volume_24h` descending
   - Return top `count` symbols as list[str]

6. Add `HistoricalDataSettings` class to `src/bot/config.py`:
   - Inherits from `BaseSettings` with `SettingsConfigDict(env_prefix="HISTORICAL_")`
   - Fields: `enabled: bool = True`, `db_path: str = "data/historical.db"`, `lookback_days: int = 365`, `ohlcv_interval: str = "1h"`, `top_pairs_count: int = 20`, `pair_reeval_interval_hours: int = 168` (weekly), `max_retries: int = 5`, `retry_base_delay: float = 1.0`, `fetch_batch_delay: float = 0.1`
   - Add `historical: HistoricalDataSettings = HistoricalDataSettings()` field to `AppSettings`
  </action>
  <verify>
    - `python -c "from bot.data.models import HistoricalFundingRate, OHLCVCandle; print('models OK')"` succeeds
    - `python -c "from bot.data.database import HistoricalDatabase; print('database OK')"` succeeds
    - `python -c "from bot.data.pair_selector import select_top_pairs; print('pair_selector OK')"` succeeds
    - `python -c "from bot.config import HistoricalDataSettings, AppSettings; s = AppSettings(); print(f'historical enabled={s.historical.enabled}')"` succeeds
    - `python -c "import asyncio; from bot.data.database import HistoricalDatabase; async def t(): db = HistoricalDatabase('/tmp/test_hist.db'); await db.connect(); await db.close(); asyncio.run(t()); print('db connect/close OK')"` succeeds
    - Existing tests pass: `python -m pytest tests/ -x -q`
  </verify>
  <done>
    - HistoricalFundingRate and OHLCVCandle dataclasses exist with Decimal fields
    - HistoricalDatabase creates all 5 tables with correct schemas and indexes on connect()
    - select_top_pairs filters USDT perpetuals and returns top N by volume
    - HistoricalDataSettings accessible via AppSettings().historical
    - aiosqlite installed and importable
    - All existing tests still pass
  </done>
</task>

<task type="auto">
  <name>Task 2: Exchange client historical data methods</name>
  <files>
    src/bot/exchange/client.py
    src/bot/exchange/bybit_client.py
  </files>
  <action>
1. Add two new abstract methods to `ExchangeClient` ABC in `src/bot/exchange/client.py`:

   ```python
   @abstractmethod
   async def fetch_funding_rate_history(
       self,
       symbol: str,
       limit: int = 200,
       params: dict | None = None,
   ) -> list[dict]:
       """Fetch historical funding rate records.

       Returns list of dicts with keys: symbol, fundingRate, timestamp, datetime, info.
       Bybit max limit: 200 records per call.
       """
       ...

   @abstractmethod
   async def fetch_ohlcv(
       self,
       symbol: str,
       timeframe: str = "1h",
       since: int | None = None,
       limit: int = 1000,
       params: dict | None = None,
   ) -> list[list]:
       """Fetch OHLCV candle data.

       Returns list of [timestamp_ms, open, high, low, close, volume].
       Bybit max limit: 1000 records per call.
       """
       ...
   ```

2. Implement both methods in `BybitClient` in `src/bot/exchange/bybit_client.py`:

   `fetch_funding_rate_history`: Call `self._exchange.fetch_funding_rate_history(symbol, limit=limit, params=params or {})`. This is a direct ccxt unified method call -- ccxt handles the Bybit v5 API conversion. Log at debug level: symbol, limit, and params used.

   `fetch_ohlcv`: Call `self._exchange.fetch_ohlcv(symbol, timeframe=timeframe, since=since, limit=limit, params=params or {})`. This is a direct ccxt unified method call. Log at debug level: symbol, timeframe, limit.

   IMPORTANT: Do NOT implement pagination here. These methods are single-call wrappers around ccxt. Pagination is handled by the HistoricalDataFetcher in plan 02. Do NOT use ccxt's experimental `paginate: True` parameter -- it has known bugs with Bybit (see research pitfall #1).
  </action>
  <verify>
    - `python -c "from bot.exchange.client import ExchangeClient; print([m for m in dir(ExchangeClient) if 'funding_rate_history' in m or 'ohlcv' in m])"` shows both methods
    - `python -c "from bot.exchange.bybit_client import BybitClient; print('bybit has methods:', hasattr(BybitClient, 'fetch_funding_rate_history'), hasattr(BybitClient, 'fetch_ohlcv'))"` shows True, True
    - Existing tests pass: `python -m pytest tests/ -x -q`
  </verify>
  <done>
    - ExchangeClient ABC has fetch_funding_rate_history and fetch_ohlcv abstract methods
    - BybitClient implements both as thin wrappers around ccxt async methods
    - No pagination logic in these methods (delegation to fetcher)
    - All existing tests still pass
  </done>
</task>

</tasks>

<verification>
- All imports work: `python -c "from bot.data import models, database, pair_selector; from bot.config import HistoricalDataSettings"`
- Database creates cleanly: create HistoricalDatabase with temp path, connect, verify tables exist via SQL query, close
- Exchange client methods exist on both ABC and concrete class
- No regressions: `python -m pytest tests/ -x -q`
</verification>

<success_criteria>
- src/bot/data/ package exists with models.py, database.py, pair_selector.py
- HistoricalDatabase.connect() creates 5 tables with proper schemas
- ExchangeClient has 2 new abstract methods, BybitClient implements them
- HistoricalDataSettings accessible at AppSettings().historical
- aiosqlite in pyproject.toml and installed
- All existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/04-historical-data-foundation/04-01-SUMMARY.md`
</output>
