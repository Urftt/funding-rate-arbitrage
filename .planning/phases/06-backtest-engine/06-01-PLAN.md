---
phase: 06-backtest-engine
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/bot/backtest/__init__.py
  - src/bot/backtest/models.py
  - src/bot/backtest/executor.py
  - src/bot/backtest/data_wrapper.py
  - src/bot/config.py
  - src/bot/pnl/tracker.py
autonomous: true

must_haves:
  truths:
    - "BacktestConfig holds all parameters needed for a single backtest run (symbol, date range, strategy mode, thresholds, weights)"
    - "BacktestExecutor fills orders at historical prices using the Executor ABC, making PositionManager unaware it is backtesting"
    - "BacktestDataStoreWrapper enforces time boundaries on all data queries, preventing look-ahead bias"
    - "PnLTracker accepts an optional time function so backtest can inject simulated timestamps"
  artifacts:
    - path: "src/bot/backtest/models.py"
      provides: "BacktestConfig, BacktestResult, EquityPoint, SweepResult dataclasses"
      contains: "class BacktestConfig"
    - path: "src/bot/backtest/executor.py"
      provides: "BacktestExecutor implementing Executor ABC"
      contains: "class BacktestExecutor(Executor)"
    - path: "src/bot/backtest/data_wrapper.py"
      provides: "BacktestDataStoreWrapper with time-bounded queries"
      contains: "class BacktestDataStoreWrapper"
    - path: "src/bot/config.py"
      provides: "BacktestSettings with BACKTEST_ env prefix"
      contains: "class BacktestSettings"
  key_links:
    - from: "src/bot/backtest/executor.py"
      to: "src/bot/execution/executor.py"
      via: "ABC inheritance"
      pattern: "class BacktestExecutor\\(Executor\\)"
    - from: "src/bot/backtest/data_wrapper.py"
      to: "src/bot/data/store.py"
      via: "delegation with time filter"
      pattern: "self\\._store\\.get_funding_rates"
    - from: "src/bot/pnl/tracker.py"
      to: "time injection"
      via: "optional time_fn parameter"
      pattern: "time_fn.*Callable"
---

<objective>
Create the foundational types and components for the backtest engine: data models, configuration, BacktestExecutor (Executor ABC implementation for historical fills), BacktestDataStoreWrapper (prevents look-ahead bias), and inject simulated time support into PnLTracker.

Purpose: These are the building blocks that Plan 02's BacktestEngine will compose. The BacktestExecutor swap is the key enabler for BKTS-02 (reuse production FeeCalculator, PnLTracker, PositionManager). The BacktestDataStoreWrapper is the key enabler for BKTS-01 (no look-ahead bias).

Output: New `src/bot/backtest/` module with models, executor, and data wrapper. Modified PnLTracker with optional time_fn. New BacktestSettings in config.
</objective>

<execution_context>
@/Users/luckleineschaars/.claude/get-shit-done/workflows/execute-plan.md
@/Users/luckleineschaars/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@src/bot/execution/executor.py
@src/bot/execution/paper_executor.py
@src/bot/pnl/tracker.py
@src/bot/pnl/fee_calculator.py
@src/bot/data/store.py
@src/bot/data/models.py
@src/bot/config.py
@src/bot/models.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create backtest data models and configuration</name>
  <files>
    src/bot/backtest/__init__.py
    src/bot/backtest/models.py
    src/bot/config.py
  </files>
  <action>
Create the `src/bot/backtest/` package.

**src/bot/backtest/__init__.py**: Export public names: `BacktestConfig`, `BacktestResult`, `EquityPoint`, `SweepResult`, `BacktestExecutor`, `BacktestDataStoreWrapper`.

**src/bot/backtest/models.py**: Create dataclasses using the project convention (Decimal for all money, dataclass not pydantic for data models):

1. `BacktestConfig`:
   - `symbol: str` -- single perpetual symbol (e.g., "BTC/USDT:USDT")
   - `start_ms: int` -- start timestamp in milliseconds
   - `end_ms: int` -- end timestamp in milliseconds
   - `strategy_mode: str = "simple"` -- "simple" or "composite"
   - `initial_capital: Decimal = Decimal("10000")`
   - Simple strategy params: `min_funding_rate: Decimal = Decimal("0.0003")`, `exit_funding_rate: Decimal = Decimal("0.0001")`
   - Composite strategy params: `entry_threshold: Decimal = Decimal("0.5")`, `exit_threshold: Decimal = Decimal("0.3")`, `weight_rate_level: Decimal = Decimal("0.35")`, `weight_trend: Decimal = Decimal("0.25")`, `weight_persistence: Decimal = Decimal("0.25")`, `weight_basis: Decimal = Decimal("0.15")`
   - Signal params: `trend_ema_span: int = 6`, `persistence_threshold: Decimal = Decimal("0.0003")`, `persistence_max_periods: int = 30`
   - Method `with_overrides(**kwargs) -> BacktestConfig` using `dataclasses.replace(self, **kwargs)`
   - Method `to_signal_settings() -> SignalSettings` that constructs a SignalSettings from the composite params (for passing to SignalEngine)
   - Method `to_dict() -> dict` for JSON serialization (convert Decimal to str, include all fields)

2. `EquityPoint`:
   - `timestamp_ms: int`
   - `equity: Decimal` -- net P&L at this point

3. `BacktestMetrics`:
   - `total_trades: int`
   - `winning_trades: int`
   - `net_pnl: Decimal`
   - `total_fees: Decimal`
   - `total_funding: Decimal`
   - `sharpe_ratio: Decimal | None`
   - `max_drawdown: Decimal | None`
   - `win_rate: Decimal | None`
   - `duration_days: int`

4. `BacktestResult`:
   - `config: BacktestConfig`
   - `equity_curve: list[EquityPoint]`
   - `metrics: BacktestMetrics`
   - Method `to_dict() -> dict` for JSON serialization

5. `SweepResult`:
   - `param_grid: dict[str, list]` -- the parameter grid that was swept
   - `results: list[tuple[dict, BacktestResult]]` -- (param_combination, result) pairs
   - Method `to_dict() -> dict` for JSON serialization

**src/bot/config.py**: Add `BacktestSettings` class after `SignalSettings`:
```python
class BacktestSettings(BaseSettings):
    """Backtest engine configuration."""
    model_config = SettingsConfigDict(env_prefix="BACKTEST_")

    default_initial_capital: Decimal = Decimal("10000")
    slippage_bps: Decimal = Decimal("5")  # 5 basis points = 0.05%
    max_concurrent_positions: int = 5
```

Add `backtest: BacktestSettings = BacktestSettings()` field to `AppSettings`.

CRITICAL: All monetary values MUST use Decimal. Follow the project convention from existing models.py and config.py. Import `from decimal import Decimal` and `from dataclasses import dataclass, field`.
  </action>
  <verify>
    Run `python -c "from bot.backtest.models import BacktestConfig, BacktestResult, EquityPoint, SweepResult, BacktestMetrics; print('models OK')"` to verify imports.
    Run `python -c "from bot.config import BacktestSettings, AppSettings; s = BacktestSettings(); print(s.default_initial_capital); a = AppSettings(); print(a.backtest.slippage_bps)"` to verify config.
    Run `python -c "from bot.backtest.models import BacktestConfig; from decimal import Decimal; c = BacktestConfig(symbol='BTC/USDT:USDT', start_ms=0, end_ms=1000); c2 = c.with_overrides(min_funding_rate=Decimal('0.0005')); print(c2.min_funding_rate); print(c.to_dict())"` to verify methods.
  </verify>
  <done>
    BacktestConfig, BacktestResult, EquityPoint, SweepResult, BacktestMetrics dataclasses exist with Decimal fields. BacktestSettings is in config.py with BACKTEST_ env prefix. AppSettings includes backtest field. with_overrides, to_signal_settings, and to_dict methods work correctly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create BacktestExecutor, BacktestDataStoreWrapper, and inject time_fn into PnLTracker</name>
  <files>
    src/bot/backtest/executor.py
    src/bot/backtest/data_wrapper.py
    src/bot/pnl/tracker.py
  </files>
  <action>
**src/bot/backtest/executor.py**: Create `BacktestExecutor` that implements `Executor` ABC.

Pattern: Follow PaperExecutor closely (same slippage model, same fee calculation), but instead of reading prices from TickerService, maintain an internal `_current_prices: dict[str, Decimal]` dict that the engine updates at each timestamp.

Key methods:
- `__init__(self, fee_settings: FeeSettings, slippage_bps: Decimal = Decimal("5"))` -- slippage in basis points
- `set_prices(self, prices: dict[str, Decimal]) -> None` -- called by engine before each timestamp
- `set_current_time(self, timestamp: float) -> None` -- for timestamp on OrderResult
- `async place_order(self, request: OrderRequest) -> OrderResult` -- fill at current historical price with slippage. Use `f"bt_{uuid4().hex[:12]}"` for order_id. Set `is_simulated=True`. Fee calculation: `request.quantity * fill_price * fee_rate` (same as PaperExecutor). Use `self._current_time` for timestamp.
- `async cancel_order(self, order_id, symbol, category="linear") -> bool` -- always return True

IMPORTANT: Do NOT use TickerService. The executor gets prices injected via `set_prices()`. This is a key design difference from PaperExecutor.

**src/bot/backtest/data_wrapper.py**: Create `BacktestDataStoreWrapper` that wraps `HistoricalDataStore`.

Purpose: Prevents look-ahead bias by automatically capping all queries at the current simulated time. The SignalEngine calls `data_store.get_funding_rates(symbol=...)` without time bounds -- this wrapper intercepts and adds `until_ms <= current_backtest_time`.

Key methods:
- `__init__(self, store: HistoricalDataStore)` -- wrap the real store
- `set_current_time(self, timestamp_ms: int) -> None` -- advance simulated clock
- `async get_funding_rates(self, symbol, since_ms=None, until_ms=None) -> list[HistoricalFundingRate]` -- delegate to store but cap `until_ms` at `self._current_time_ms`
- `async get_ohlcv_candles(self, symbol, since_ms=None, until_ms=None) -> list[OHLCVCandle]` -- same pattern
- `async get_data_status(self) -> dict` -- delegate unchanged (metadata query, not time-sensitive)
- `async get_tracked_pairs(self, active_only=True) -> list[dict]` -- delegate unchanged

The wrapper must match the HistoricalDataStore interface methods that SignalEngine uses (get_funding_rates, get_ohlcv_candles) so it can be passed in place of a real store. It does NOT need to implement write methods.

**src/bot/pnl/tracker.py**: Add optional `time_fn` parameter to PnLTracker:

1. Add import: `from typing import Callable`
2. Add `time_fn: Callable[[], float] = time.time` parameter to `__init__` (AFTER existing params).
3. Store as `self._time_fn = time_fn`
4. Replace all `time.time()` calls in the class with `self._time_fn()`:
   - `record_close()`: Change `pnl.closed_at = time.time()` to `pnl.closed_at = self._time_fn()`
   - `record_funding_payment()`: Change `timestamp=time.time()` in FundingPayment to `timestamp=self._time_fn()`

This is a NON-BREAKING change: existing callers pass no time_fn arg and get the default `time.time`. Backtest callers pass a lambda that returns the simulated timestamp.

Update `src/bot/backtest/__init__.py` to also export `BacktestExecutor` and `BacktestDataStoreWrapper`.
  </action>
  <verify>
    Run `python -c "from bot.backtest.executor import BacktestExecutor; from bot.config import FeeSettings; e = BacktestExecutor(FeeSettings()); print('executor OK')"` to verify executor imports.
    Run `python -c "from bot.backtest.data_wrapper import BacktestDataStoreWrapper; print('wrapper OK')"` to verify wrapper imports.
    Run `python -c "from bot.pnl.tracker import PnLTracker; import inspect; sig = inspect.signature(PnLTracker.__init__); assert 'time_fn' in sig.parameters; print('time_fn injected OK')"` to verify time_fn parameter.
    Run `python -m pytest tests/ -x -q --timeout=30 2>&1 | tail -5` to verify no existing tests broken by PnLTracker change.
  </verify>
  <done>
    BacktestExecutor fills orders at historical prices via set_prices()/set_current_time() without TickerService dependency. BacktestDataStoreWrapper enforces time boundaries on all read queries. PnLTracker accepts optional time_fn (defaulting to time.time) with no breaking changes to existing code. All existing tests pass.
  </done>
</task>

</tasks>

<verification>
1. `python -c "from bot.backtest import BacktestConfig, BacktestResult, BacktestExecutor, BacktestDataStoreWrapper"` succeeds
2. `python -c "from bot.config import AppSettings; a = AppSettings(); print(a.backtest)"` shows BacktestSettings
3. All existing tests pass: `python -m pytest tests/ -x -q`
4. BacktestExecutor inherits from Executor ABC (can be type-checked)
5. PnLTracker time_fn parameter has no effect when not provided (backward compatible)
</verification>

<success_criteria>
- New `src/bot/backtest/` package exists with models.py, executor.py, data_wrapper.py, __init__.py
- BacktestConfig.with_overrides() returns a modified copy
- BacktestConfig.to_signal_settings() returns a valid SignalSettings
- BacktestExecutor.place_order() returns OrderResult with historical prices and is_simulated=True
- BacktestDataStoreWrapper caps all queries at current simulated time
- PnLTracker uses self._time_fn() instead of time.time() for all timestamps
- No existing tests broken
</success_criteria>

<output>
After completion, create `.planning/phases/06-backtest-engine/06-01-SUMMARY.md`
</output>
