---
phase: 06-backtest-engine
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - src/bot/backtest/engine.py
  - src/bot/backtest/runner.py
  - src/bot/backtest/__init__.py
autonomous: true

must_haves:
  truths:
    - "BacktestEngine replays historical funding rate timestamps in chronological order without look-ahead bias"
    - "At each timestamp, the engine constructs a FundingRateData snapshot visible at that moment and feeds it through the strategy"
    - "The engine reuses production FeeCalculator and PnLTracker for all fee and P&L computations (BKTS-02)"
    - "Funding settlements are simulated at each funding period for open positions"
    - "run_backtest() returns a complete BacktestResult with equity curve and metrics"
    - "Both simple and composite strategy modes produce valid results"
  artifacts:
    - path: "src/bot/backtest/engine.py"
      provides: "BacktestEngine with async run() method for event-driven replay"
      contains: "class BacktestEngine"
    - path: "src/bot/backtest/runner.py"
      provides: "run_backtest() entry point for single backtest execution"
      contains: "async def run_backtest"
  key_links:
    - from: "src/bot/backtest/engine.py"
      to: "src/bot/backtest/executor.py"
      via: "BacktestExecutor.set_prices() and set_current_time() at each timestamp"
      pattern: "self\\._executor\\.set_prices"
    - from: "src/bot/backtest/engine.py"
      to: "src/bot/pnl/tracker.py"
      via: "PnLTracker.record_funding_payment() for settlement simulation"
      pattern: "self\\._pnl_tracker\\.record_funding_payment"
    - from: "src/bot/backtest/engine.py"
      to: "src/bot/backtest/data_wrapper.py"
      via: "BacktestDataStoreWrapper.set_current_time() advancing simulated clock"
      pattern: "self\\._data_wrapper\\.set_current_time"
    - from: "src/bot/backtest/runner.py"
      to: "src/bot/backtest/engine.py"
      via: "Constructs BacktestEngine with all production components wired up"
      pattern: "BacktestEngine\\("
---

<objective>
Build the core BacktestEngine that replays historical data through the strategy pipeline and the run_backtest() entry point that wires all components together.

Purpose: This is the heart of Phase 6 -- the event-driven replay loop that walks through historical funding rate timestamps, constructs data snapshots, feeds them through the same strategy logic used in production, and tracks P&L. Satisfies BKTS-01 (chronological replay, no look-ahead) and BKTS-02 (reuses production code). Also enables BKTS-05 (both strategy modes) by branching on config.strategy_mode.

Output: BacktestEngine class and run_backtest() function that produce BacktestResult with equity curve and metrics.
</objective>

<execution_context>
@/Users/luckleineschaars/.claude/get-shit-done/workflows/execute-plan.md
@/Users/luckleineschaars/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-backtest-engine/06-01-SUMMARY.md

@src/bot/backtest/models.py
@src/bot/backtest/executor.py
@src/bot/backtest/data_wrapper.py
@src/bot/pnl/tracker.py
@src/bot/pnl/fee_calculator.py
@src/bot/position/manager.py
@src/bot/position/sizing.py
@src/bot/position/delta_validator.py
@src/bot/signals/engine.py
@src/bot/market_data/opportunity_ranker.py
@src/bot/market_data/ticker_service.py
@src/bot/data/store.py
@src/bot/data/models.py
@src/bot/config.py
@src/bot/models.py
@src/bot/analytics/metrics.py
@src/bot/orchestrator.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create BacktestEngine with event-driven replay loop</name>
  <files>src/bot/backtest/engine.py</files>
  <action>
Create `BacktestEngine` class in `src/bot/backtest/engine.py`.

The engine is an event-driven replay loop that:
1. Loads all historical funding rates for the symbol in the date range
2. Loads all OHLCV candles for the symbol in the date range
3. Walks through funding rate timestamps in chronological order
4. At each timestamp, constructs the data snapshot visible at that moment
5. Feeds the snapshot through the strategy decision logic
6. Simulates funding settlement for open positions
7. Records equity points for the equity curve

**Constructor parameters:**
- `config: BacktestConfig`
- `data_store: HistoricalDataStore` -- the REAL store (not wrapped), engine creates the wrapper internally
- `fee_settings: FeeSettings`
- `backtest_settings: BacktestSettings`

The engine creates its own internal component instances:
- `BacktestExecutor` (with fee_settings and backtest_settings.slippage_bps)
- `BacktestDataStoreWrapper` (wrapping data_store)
- `FeeCalculator` (with fee_settings -- reusing production class per BKTS-02)
- `TickerService` -- create a minimal instance, not connected to any exchange, just used as a price container for components that require it
- `PnLTracker` (with fee_calculator, ticker_service, fee_settings, time_fn=lambda: simulated timestamp) -- reusing production class per BKTS-02
- `PositionSizer`, `DeltaValidator`, `PositionManager` (with BacktestExecutor) -- reusing production classes per BKTS-02
- `SignalEngine` (if composite mode, constructed with config.to_signal_settings() and BacktestDataStoreWrapper)
- `OpportunityRanker` (for simple mode)

**Simulated time management:**
- Maintain `self._current_time_ms: int` and `self._current_time_s: float` (seconds)
- Before each timestamp step: update executor prices via `set_prices()`, update executor time via `set_current_time()`, update data wrapper time via `set_current_time()`
- PnLTracker gets `time_fn=lambda: self._current_time_s`

**Static markets dict:**
The strategy pipeline needs a `markets` dict for spot symbol derivation. Build it statically at startup from the backtest symbol:
```python
# For "BTC/USDT:USDT", derive base="BTC", quote="USDT"
base = config.symbol.split("/")[0]
quote = config.symbol.split("/")[1].split(":")[0]
spot_symbol = f"{base}/{quote}"
self._markets = {
    config.symbol: {"base": base, "quote": quote, "spot": False, "active": True, "type": "swap"},
    spot_symbol: {"base": base, "quote": quote, "spot": True, "active": True, "type": "spot"},
}
```

**Core `async run() -> BacktestResult` method:**

1. Load funding rates: `all_rates = await data_store.get_funding_rates(symbol, since_ms=config.start_ms, until_ms=config.end_ms)`
2. Load OHLCV candles: `all_candles = await data_store.get_ohlcv_candles(symbol, since_ms=config.start_ms, until_ms=config.end_ms)`. Build a dict mapping `timestamp_ms -> OHLCVCandle` for O(1) lookup. Also build a sorted list for finding the most recent candle at any timestamp.
3. Define helper `_get_price_at(timestamp_ms) -> Decimal` that returns the close price of the most recent OHLCV candle with `timestamp_ms <= target`. Use bisect_right on the sorted candle timestamps list.
4. Walk through each funding rate record chronologically:
   a. Set `self._current_time_ms = fr.timestamp_ms`, `self._current_time_s = fr.timestamp_ms / 1000.0`
   b. Get price at this timestamp: `price = _get_price_at(fr.timestamp_ms)`. If no candle available, skip this timestamp.
   c. Update executor: `self._executor.set_prices({config.symbol: price, spot_symbol: price})`, `self._executor.set_current_time(self._current_time_s)`
   d. Update data wrapper: `self._data_wrapper.set_current_time(fr.timestamp_ms)`
   e. Update ticker service: `await self._ticker_service.update_price(spot_symbol, price)` and `await self._ticker_service.update_price(config.symbol, price)` -- check TickerService API for the actual method name
   f. Build FundingRateData snapshot: `FundingRateData(symbol=config.symbol, rate=fr.funding_rate, next_funding_time=fr.timestamp_ms + fr.interval_hours * 3600 * 1000, interval_hours=fr.interval_hours, mark_price=price, volume_24h=Decimal("1000000"))` (use placeholder volume since it's not a filter in backtest)
   g. **Simulate funding settlement** for open positions: For each open position in PositionManager, call `self._pnl_tracker.record_funding_payment(position_id=pos.id, funding_rate=fr.funding_rate, mark_price=price, quantity=pos.quantity)`
   h. **Strategy decision:** Branch on `config.strategy_mode`:
      - "simple": Check if we should CLOSE (rate < exit_funding_rate) or OPEN (rate >= min_funding_rate and no position open for this symbol). Use simple threshold comparison directly -- do NOT call OpportunityRanker for simplicity, since we're backtesting a single symbol.
      - "composite": Use `await self._signal_engine.score_opportunities([funding_snapshot], self._markets)`. If score passes entry threshold and no position open, open. If score below exit threshold and position open, close.
   i. **Open position** (if decided): Call `await self._position_manager.open_position(spot_symbol, config.symbol, config.initial_capital, spot_instrument, perp_instrument)`. Create minimal InstrumentInfo with generous limits (backtest doesn't need exchange constraint validation). Track position in PnLTracker: `self._pnl_tracker.record_open(position, entry_fee)`.
   j. **Close position** (if decided): Call `await self._position_manager.close_position(pos.id)`. Record in PnLTracker: `self._pnl_tracker.record_close(pos.id, spot_exit_price, perp_exit_price, exit_fee)`.
   k. **Record equity point**: Get portfolio summary from PnLTracker and append `EquityPoint(timestamp_ms=fr.timestamp_ms, equity=portfolio["net_portfolio_pnl"])`.

5. After loop: Close any remaining open positions at the last available price.
6. Compute metrics from PnLTracker using `bot.analytics.metrics` functions (sharpe_ratio, max_drawdown, win_rate).
7. Return `BacktestResult(config=config, equity_curve=equity_curve, metrics=metrics)`.

**Error handling:** Wrap position open/close in try/except. Log but continue on individual operation failures. The backtest should be resilient to edge cases (e.g., price unavailable at a specific timestamp).

**Important anti-patterns to AVOID:**
- Do NOT use `time.time()` anywhere in engine code. Always use simulated timestamps.
- Do NOT call `orchestrator._autonomous_cycle()`. Extract the decision logic inline.
- Do NOT load all data for all pairs. This is single-symbol backtest.
  </action>
  <verify>
    Run `python -c "from bot.backtest.engine import BacktestEngine; print('engine import OK')"` to verify imports.
    The engine will be fully tested via the runner in Task 2.
  </verify>
  <done>
    BacktestEngine exists with async run() method that replays historical data chronologically, simulates funding settlements, makes strategy decisions using production FeeCalculator/PnLTracker/PositionManager, and returns BacktestResult with equity curve and metrics.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create run_backtest() runner and validate end-to-end</name>
  <files>
    src/bot/backtest/runner.py
    src/bot/backtest/__init__.py
  </files>
  <action>
**src/bot/backtest/runner.py**: Create the high-level entry point functions.

1. `async def run_backtest(config: BacktestConfig, db_path: str = "data/historical.db", fee_settings: FeeSettings | None = None, backtest_settings: BacktestSettings | None = None) -> BacktestResult`:
   - Opens database connection: `async with HistoricalDatabase(db_path) as database:`
   - Creates `HistoricalDataStore(database)`
   - Creates `FeeSettings()` if not provided
   - Creates `BacktestSettings()` if not provided
   - Creates `BacktestEngine(config, data_store, fee_settings, backtest_settings)`
   - Runs `result = await engine.run()`
   - Returns result
   - Includes proper logging of start/completion with timing

2. `async def run_comparison(config_simple: BacktestConfig, config_composite: BacktestConfig, db_path: str = "data/historical.db") -> tuple[BacktestResult, BacktestResult]`:
   - Validates that both configs have the same symbol, start_ms, end_ms (just warning if different)
   - Validates config_simple.strategy_mode == "simple" and config_composite.strategy_mode == "composite"
   - Runs both backtests sequentially (same database connection)
   - Returns `(simple_result, composite_result)` tuple
   - This satisfies BKTS-05 (v1.0 vs v1.1 side-by-side comparison)

3. `async def run_backtest_cli(symbol: str, start_date: str, end_date: str, strategy_mode: str = "simple", **kwargs) -> BacktestResult`:
   - Convenience function that converts date strings ("2025-01-01") to millisecond timestamps
   - Validates symbol and date range
   - Creates BacktestConfig from arguments
   - Calls run_backtest()
   - Logs summary to console: net P&L, total trades, sharpe ratio, max drawdown, win rate
   - This is the entry point that main.py or a CLI script can call

**src/bot/backtest/__init__.py**: Update exports to include `run_backtest`, `run_comparison`, `run_backtest_cli`, `BacktestEngine`.

After creating both files, do a basic integration test by running:
```python
# Quick smoke test -- will fail if no data in DB, but should not fail on import/construction
import asyncio
from bot.backtest.runner import run_backtest
from bot.backtest.models import BacktestConfig
config = BacktestConfig(symbol="BTC/USDT:USDT", start_ms=0, end_ms=1000, strategy_mode="simple")
# Just verify the function is callable and types are correct
print("runner imports OK, types correct")
```

Handle the case where the database has no data for the requested symbol/date range: return a BacktestResult with empty equity curve, zero metrics, and a warning log message.
  </action>
  <verify>
    Run `python -c "from bot.backtest.runner import run_backtest, run_comparison, run_backtest_cli; print('runner imports OK')"`.
    Run `python -c "from bot.backtest import BacktestEngine, run_backtest, BacktestConfig, BacktestResult; print('all exports OK')"`.
    Run `python -m pytest tests/ -x -q --timeout=30 2>&1 | tail -5` to verify no existing tests broken.
  </verify>
  <done>
    run_backtest() entry point wires all components (database, data store, engine) and returns BacktestResult. run_comparison() enables v1.0 vs v1.1 side-by-side execution. run_backtest_cli() provides date-string convenience for CLI usage. All functions handle empty data gracefully.
  </done>
</task>

</tasks>

<verification>
1. `python -c "from bot.backtest.engine import BacktestEngine"` succeeds
2. `python -c "from bot.backtest.runner import run_backtest, run_comparison"` succeeds
3. BacktestEngine.run() produces BacktestResult with equity_curve list and BacktestMetrics
4. run_comparison() accepts two configs and returns tuple of results
5. All existing tests pass: `python -m pytest tests/ -x -q`
6. No use of `time.time()` in engine.py or runner.py (grep verification)
</verification>

<success_criteria>
- BacktestEngine replays funding rate timestamps in chronological order
- At each timestamp, only data with timestamp_ms <= current_time is visible (no look-ahead)
- FeeCalculator.calculate_funding_payment() is called for settlement (not custom math)
- PnLTracker.record_open/record_close/record_funding_payment are used for all P&L tracking
- PositionManager.open_position/close_position are used for all position lifecycle
- Both "simple" and "composite" strategy_mode produce BacktestResult
- run_backtest() creates all components and returns BacktestResult
- run_comparison() runs both strategies and returns tuple
</success_criteria>

<output>
After completion, create `.planning/phases/06-backtest-engine/06-02-SUMMARY.md`
</output>
