---
phase: 03-dashboard-analytics
plan: 05
type: execute
wave: 3
depends_on: ["03-04"]
files_modified:
  - src/bot/main.py

autonomous: false

must_haves:
  truths:
    - "Bot starts with embedded dashboard on configured port"
    - "Dashboard receives real-time updates via WebSocket every N seconds"
    - "Stopping the bot also stops the dashboard server cleanly"
    - "Dashboard is accessible at http://localhost:8080 when bot is running"
    - "DASHBOARD_ENABLED=false skips dashboard startup"
  artifacts:
    - path: "src/bot/main.py"
      provides: "Unified entry point running bot + dashboard in single asyncio event loop"
      contains: "create_dashboard_app"
  key_links:
    - from: "src/bot/main.py"
      to: "src/bot/dashboard/app.py"
      via: "create_dashboard_app with lifespan"
      pattern: "create_dashboard_app"
    - from: "src/bot/main.py"
      to: "src/bot/orchestrator.py"
      via: "lifespan context starts orchestrator as background task"
      pattern: "orchestrator\\.start"
    - from: "src/bot/main.py"
      to: "uvicorn.Server"
      via: "programmatic uvicorn server in asyncio loop"
      pattern: "uvicorn\\.Server"
---

<objective>
Wire the dashboard into the bot's main entry point using FastAPI's lifespan context manager and uvicorn's programmatic API. Run both the trading bot and dashboard server in a single asyncio event loop.

Purpose: This is the final integration step. The user runs one command (`funding-arb` or `python -m bot.main`) and gets both the trading bot and the dashboard. The lifespan manages startup/shutdown of all components.

Output: Modified main.py that runs bot + dashboard together. Human-verified working dashboard.
</objective>

<execution_context>
@/Users/luckleineschaars/.claude/get-shit-done/workflows/execute-plan.md
@/Users/luckleineschaars/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-dashboard-analytics/03-RESEARCH.md

@src/bot/main.py
@src/bot/dashboard/app.py
@src/bot/orchestrator.py
@src/bot/config.py

# Need all prior summaries for integration
@.planning/phases/03-dashboard-analytics/03-01-SUMMARY.md
@.planning/phases/03-dashboard-analytics/03-02-SUMMARY.md
@.planning/phases/03-dashboard-analytics/03-03-SUMMARY.md
@.planning/phases/03-dashboard-analytics/03-04-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Integrate dashboard into main.py with lifespan and uvicorn</name>
  <files>
    src/bot/main.py
  </files>
  <action>
Rewrite `src/bot/main.py` to run the bot + dashboard in a single asyncio event loop.

**Key changes:**

1. Add imports:
   ```python
   from contextlib import asynccontextmanager
   from fastapi import FastAPI
   import uvicorn
   from bot.dashboard.app import create_dashboard_app
   ```

2. Extract all component wiring (steps 1-15 from current `run()`) into a helper function `_build_components(settings)` that returns a dict of all components. This keeps `run()` clean.

3. Create lifespan context manager:
   ```python
   @asynccontextmanager
   async def lifespan(app: FastAPI):
       """Start bot components, run orchestrator as background task, clean up on shutdown."""
       settings = app.state.settings
       components = app.state.components

       # Store all components on app.state for route access
       app.state.orchestrator = components["orchestrator"]
       app.state.position_manager = components["position_manager"]
       app.state.pnl_tracker = components["pnl_tracker"]
       app.state.funding_monitor = components["funding_monitor"]
       app.state.risk_manager = components["risk_manager"]
       app.state.ticker_service = components["ticker_service"]
       app.state.exchange_client = components["exchange_client"]
       app.state.emergency_controller = components["emergency_controller"]

       # Connect to exchange
       await components["exchange_client"].connect()

       # Start orchestrator as background task
       bot_task = asyncio.create_task(components["orchestrator"].start())

       # Start dashboard update loop as background task
       from bot.dashboard.routes.ws import hub as dashboard_hub
       app.state.hub = dashboard_hub
       update_task = asyncio.create_task(
           _dashboard_update_loop(app, settings.dashboard.update_interval)
       )

       yield

       # Shutdown
       update_task.cancel()
       try:
           await update_task
       except asyncio.CancelledError:
           pass

       await components["orchestrator"].stop()
       bot_task.cancel()
       try:
           await bot_task
       except asyncio.CancelledError:
           pass

       await components["exchange_client"].close()
       logger.info("funding_rate_arbitrage_stopped")
   ```

4. Create `_dashboard_update_loop(app, interval)` async function:
   - Import the `dashboard_update_loop` from the dashboard package (defined in Plan 04)
   - Or implement inline: loop with `asyncio.sleep(interval)`, render partials, broadcast via hub
   - Must handle exceptions gracefully (log and continue, never crash)

5. Rewrite `run()` to:
   ```python
   async def run() -> None:
       settings = AppSettings()
       setup_logging(settings.log_level)
       logger = get_logger("bot.main")

       components = await _build_components(settings)

       if settings.dashboard.enabled:
           app = create_dashboard_app(lifespan=lifespan)
           app.state.settings = settings
           app.state.components = components

           # Setup signal handlers
           _setup_signal_handlers(components["orchestrator"], components["emergency_controller"])

           logger.info("starting_with_dashboard", host=settings.dashboard.host, port=settings.dashboard.port)

           config = uvicorn.Config(
               app,
               host=settings.dashboard.host,
               port=settings.dashboard.port,
               log_level="warning",  # Suppress uvicorn access logs
           )
           server = uvicorn.Server(config)
           await server.serve()
       else:
           # Dashboard disabled: run bot directly (original behavior)
           _setup_signal_handlers(components["orchestrator"], components["emergency_controller"])
           logger.info("starting_without_dashboard", mode=settings.trading.mode)
           try:
               await components["exchange_client"].connect()
               await components["orchestrator"].start()
           finally:
               await components["exchange_client"].close()
               logger.info("funding_rate_arbitrage_stopped")
   ```

6. Extract signal handler setup into `_setup_signal_handlers(orchestrator, emergency_controller)`:
   - Same SIGINT/SIGTERM/SIGUSR1 handlers as current code
   - Move the loop.add_signal_handler calls here

7. Make `_build_components` an async function that creates all components (steps 3-15 from current run()):
   - Return dict with keys: orchestrator, position_manager, pnl_tracker, funding_monitor, risk_manager, ticker_service, exchange_client, emergency_controller, ranker, fee_calculator, etc.
   - Do NOT call exchange_client.connect() here -- that happens in lifespan

8. Keep `main()` and `if __name__ == "__main__"` unchanged.

**Important considerations:**
- Signal handlers must be set up AFTER the event loop is running. When using uvicorn, the lifespan sets up the loop. For the non-dashboard path, set them in run() as before.
- uvicorn.Server.serve() blocks until shutdown, so the lifespan manages the bot lifecycle.
- Set uvicorn log_level to "warning" to avoid noisy access logs cluttering the bot's structlog output.
  </action>
  <verify>
Run from repo root:
```
python -c "
from bot.main import _build_components, main
from bot.config import AppSettings
import inspect
# Check _build_components exists and is async
assert inspect.iscoroutinefunction(_build_components), '_build_components should be async'
print('main.py structure OK')
"
```

Run the full test suite to check for regressions:
```
cd /Users/luckleineschaars/repos/funding-rate-arbitrage && python -m pytest tests/ -x -q 2>&1 | tail -5
```
  </verify>
  <done>
main.py runs bot + dashboard in single asyncio event loop. Lifespan manages all component lifecycle. Dashboard update loop pushes state every N seconds via WebSocket. DASHBOARD_ENABLED=false preserves original bot-only behavior. All existing tests pass.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 2: Verify dashboard loads and displays correctly</name>
  <files>src/bot/main.py</files>
  <action>
Human verification of the complete dashboard. What was built: Complete web dashboard integrated into the bot with positions panel, funding rates overview, trade history, bot controls, balance breakdown, config form, and analytics panel -- all powered by real-time WebSocket updates.

Verification steps:

1. Start the bot in paper mode:
   ```
   cd /Users/luckleineschaars/repos/funding-rate-arbitrage
   TRADING_MODE=paper python -m bot.main
   ```
   Expected: Bot starts, logs show "starting_with_dashboard" with host/port.

2. Open browser to http://localhost:8080
   Expected: Dark-themed dashboard loads with all 7 panels:
   - Bot Status panel (showing "Running", "paper" mode)
   - Balance panel (showing portfolio summary)
   - Analytics panel (showing "Insufficient data" since no trades yet)
   - Positions panel (showing "No open positions")
   - Funding Rates panel (showing live rates from Bybit if API keys configured, or empty if public-only)
   - Trade History panel (empty)
   - Config Form panel (showing current settings with form fields)

3. Test bot stop/start:
   - Click "Stop Bot" button -> Status changes to "Stopped"
   - Click "Start Bot" button -> Status returns to "Running"

4. Test config update:
   - Change "Min Funding Rate" to 0.0005, click "Update Config"
   - Expected: Success message shown, value persists

5. Verify real-time updates:
   - Keep dashboard open for 10+ seconds
   - Expected: Panels refresh automatically (observe network tab for WebSocket messages)

6. Stop the bot with Ctrl+C in terminal
   - Expected: Graceful shutdown, dashboard becomes unreachable
  </action>
  <verify>Human visually confirms all 7 DASH panels render correctly in browser at http://localhost:8080</verify>
  <done>User types "approved" if dashboard works correctly, or describes any issues observed.</done>
</task>

</tasks>

<verification>
1. `python -m bot.main` starts both bot and dashboard
2. http://localhost:8080 shows the dashboard with all 7 panels
3. Bot stop/start works via dashboard buttons
4. Config form updates are applied
5. WebSocket pushes real-time updates
6. Ctrl+C gracefully stops both bot and dashboard
7. DASHBOARD_ENABLED=false runs bot without dashboard (original behavior)
</verification>

<success_criteria>
- Single entry point runs both bot and dashboard
- Dashboard accessible at configured host:port
- All 7 DASH requirements visible on dashboard
- Real-time updates via WebSocket
- Graceful shutdown stops both components
- Dashboard-disabled mode preserves original behavior
- User visually confirms dashboard works correctly
</success_criteria>

<output>
After completion, create `.planning/phases/03-dashboard-analytics/03-05-SUMMARY.md`
</output>
