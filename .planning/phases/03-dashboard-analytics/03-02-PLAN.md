---
phase: 03-dashboard-analytics
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/bot/config.py
  - src/bot/pnl/tracker.py
  - src/bot/orchestrator.py

autonomous: true

must_haves:
  truths:
    - "Closed positions are retained in PnLTracker for trade history (DASH-03)"
    - "RuntimeConfig can override mutable strategy settings at runtime (DASH-06)"
    - "Orchestrator can be stopped and restarted via dashboard (DASH-04)"
    - "DashboardSettings provides host, port, enabled, and update_interval config"
  artifacts:
    - path: "src/bot/config.py"
      provides: "DashboardSettings and RuntimeConfig for dashboard configuration and runtime overrides"
      contains: "DashboardSettings"
    - path: "src/bot/pnl/tracker.py"
      provides: "Trade history retention via get_closed_positions and get_all_position_pnls"
      exports: ["PnLTracker"]
    - path: "src/bot/orchestrator.py"
      provides: "restart() method and runtime_config property for dashboard control"
      exports: ["Orchestrator"]
  key_links:
    - from: "src/bot/config.py"
      to: "src/bot/orchestrator.py"
      via: "RuntimeConfig read at cycle start"
      pattern: "runtime_config"
    - from: "src/bot/pnl/tracker.py"
      to: "dashboard routes (Plan 04)"
      via: "get_closed_positions() method"
      pattern: "get_closed_positions"
---

<objective>
Extend the existing data layer to support dashboard requirements: retain closed positions for trade history (DASH-03), add RuntimeConfig overlay for mutable settings (DASH-06), add DashboardSettings for server config, and add orchestrator restart capability (DASH-04).

Purpose: The dashboard needs data and controls that don't exist yet. This plan modifies existing components to expose the data. All changes are backward-compatible -- existing bot behavior is unchanged.

Output: Modified config.py, pnl/tracker.py, orchestrator.py with new methods and classes.
</objective>

<execution_context>
@/Users/luckleineschaars/.claude/get-shit-done/workflows/execute-plan.md
@/Users/luckleineschaars/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-dashboard-analytics/03-RESEARCH.md

@src/bot/config.py
@src/bot/pnl/tracker.py
@src/bot/orchestrator.py
@src/bot/models.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add DashboardSettings, RuntimeConfig, and extend PnLTracker for trade history</name>
  <files>
    src/bot/config.py
    src/bot/pnl/tracker.py
  </files>
  <action>
**config.py changes:**

1. Add `DashboardSettings` class (BaseSettings subclass):
   ```python
   class DashboardSettings(BaseSettings):
       model_config = SettingsConfigDict(env_prefix="DASHBOARD_")
       host: str = "0.0.0.0"
       port: int = 8080
       enabled: bool = True
       update_interval: int = 5  # seconds between WebSocket pushes
   ```

2. Add `RuntimeConfig` dataclass (NOT BaseSettings -- this is mutable runtime state):
   ```python
   @dataclass
   class RuntimeConfig:
       """Mutable runtime config overlay. Non-None fields override BaseSettings values.

       Used by the dashboard to update strategy parameters without restarting.
       Changes are applied at the start of each orchestrator cycle.
       """
       min_funding_rate: Decimal | None = None
       max_position_size_usd: Decimal | None = None
       exit_funding_rate: Decimal | None = None
       max_simultaneous_positions: int | None = None
       max_position_size_per_pair: Decimal | None = None
       min_volume_24h: Decimal | None = None
       scan_interval: int | None = None
   ```
   Import `dataclass` from dataclasses and `Decimal` from decimal (already imported).

3. Add `dashboard: DashboardSettings = DashboardSettings()` to `AppSettings`.

**pnl/tracker.py changes:**

1. Currently `record_close` marks a position as closed (sets `closed_at`) but the position stays in `self._position_pnl`. However, `PositionManager.close_position()` removes it from `_positions` via `.pop()`. The PnLTracker already retains the data -- good. But we need explicit methods to distinguish open vs closed for DASH-03.

2. Add method `get_closed_positions(self) -> list[PositionPnL]`:
   - Return `[p for p in self._position_pnl.values() if p.closed_at is not None]`
   - Sort by `closed_at` descending (most recent first)

3. Add method `get_open_position_pnls(self) -> list[PositionPnL]`:
   - Return `[p for p in self._position_pnl.values() if p.closed_at is None]`

4. Add method `get_all_position_pnls(self) -> list[PositionPnL]`:
   - Return `list(self._position_pnl.values())`
   - This is used by analytics (Plan 03) for Sharpe/drawdown calculations

5. Add `spot_exit_price` and `perp_exit_price` fields to `PositionPnL` dataclass (both `Decimal = Decimal("0")`). Update `record_close` to store these values -- they're already passed as parameters but currently unused. This data is needed for DASH-03 trade history display.

6. Add `perp_symbol` field to `PositionPnL` dataclass (`str = ""`). Set it in `record_open` from `position.perp_symbol`. This is needed for DASH-07 win rate by pair.
  </action>
  <verify>
Run from repo root:
```
python -c "
from bot.config import AppSettings, DashboardSettings, RuntimeConfig
s = AppSettings()
assert s.dashboard.port == 8080
assert s.dashboard.enabled is True
rc = RuntimeConfig()
assert rc.min_funding_rate is None
print('Config OK')
"
```

```
python -c "
from bot.pnl.tracker import PnLTracker, PositionPnL
# Check new fields exist
p = PositionPnL(position_id='test', entry_fee=__import__('decimal').Decimal('1'))
assert hasattr(p, 'spot_exit_price')
assert hasattr(p, 'perp_exit_price')
assert hasattr(p, 'perp_symbol')
print('PnLTracker fields OK')
"
```
  </verify>
  <done>
DashboardSettings provides DASHBOARD_ env-prefixed config. RuntimeConfig is a mutable dataclass for runtime overrides. PnLTracker retains closed positions with get_closed_positions(), get_open_position_pnls(), get_all_position_pnls() methods. PositionPnL has exit prices and perp_symbol fields.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add orchestrator restart capability and RuntimeConfig integration</name>
  <files>
    src/bot/orchestrator.py
  </files>
  <action>
1. Add `runtime_config` property and setter to Orchestrator:
   ```python
   def __init__(self, ...):
       # ... existing init ...
       self._runtime_config: RuntimeConfig | None = None

   @property
   def runtime_config(self) -> RuntimeConfig | None:
       return self._runtime_config

   @runtime_config.setter
   def runtime_config(self, config: RuntimeConfig) -> None:
       self._runtime_config = config
       logger.info("runtime_config_updated", config=str(config))
   ```
   Import `RuntimeConfig` from `bot.config`.

2. Add `_apply_runtime_config(self)` private method, called at the START of `_autonomous_cycle()` (before scan):
   ```python
   def _apply_runtime_config(self) -> None:
       """Apply runtime config overrides to settings if set."""
       rc = self._runtime_config
       if rc is None:
           return
       if rc.min_funding_rate is not None:
           self._settings.trading.min_funding_rate = rc.min_funding_rate
       if rc.max_position_size_usd is not None:
           self._settings.trading.max_position_size_usd = rc.max_position_size_usd
       if rc.exit_funding_rate is not None:
           self._settings.risk.exit_funding_rate = rc.exit_funding_rate
       if rc.max_simultaneous_positions is not None:
           self._settings.risk.max_simultaneous_positions = rc.max_simultaneous_positions
       if rc.max_position_size_per_pair is not None:
           self._settings.risk.max_position_size_per_pair = rc.max_position_size_per_pair
       if rc.min_volume_24h is not None:
           self._settings.risk.min_volume_24h = rc.min_volume_24h
       if rc.scan_interval is not None:
           self._settings.trading.scan_interval = rc.scan_interval
   ```
   Call `self._apply_runtime_config()` as the FIRST line of `_autonomous_cycle()`.

3. Add `async def restart(self) -> None` method:
   ```python
   async def restart(self) -> None:
       """Restart the orchestrator (stop then start the run loop).

       Used by dashboard DASH-04 to start the bot after it has been stopped.
       Does NOT close positions on stop (that's graceful shutdown behavior).
       Restarts the funding monitor and main loop.
       """
       if self._running:
           logger.info("orchestrator_restart_already_running")
           return
       logger.info("orchestrator_restarting")
       await self._funding_monitor.start()
       self._running = True
       self._last_funding_check = time.time()
       # Run loop as a background task so caller doesn't block
       asyncio.create_task(self._run_loop_with_cleanup())
   ```

4. Add `async def _run_loop_with_cleanup(self) -> None`:
   ```python
   async def _run_loop_with_cleanup(self) -> None:
       """Run loop wrapper that cleans up funding monitor on exit."""
       try:
           await self._run_loop()
       finally:
           await self._funding_monitor.stop()
           logger.info("orchestrator_stopped")
   ```

5. Update `stop()` to NOT close positions when called from dashboard (add a `close_positions: bool = True` parameter):
   Actually, keep stop() as-is (always closes positions on graceful stop). The dashboard "stop" should close positions. The dashboard "start" calls restart(). This is the safer default for a trading bot.

6. Add `@property def is_running(self) -> bool` that returns `self._running`. The `get_status()` method already exposes this in a dict, but a direct property is cleaner for the dashboard update loop.
  </action>
  <verify>
Run from repo root:
```
python -c "
from bot.orchestrator import Orchestrator
import inspect
assert hasattr(Orchestrator, 'restart'), 'Missing restart method'
assert hasattr(Orchestrator, 'runtime_config'), 'Missing runtime_config'
sig = inspect.signature(Orchestrator.restart)
print('Orchestrator extensions OK')
"
```

Run existing tests to confirm no regression:
```
cd /Users/luckleineschaars/repos/funding-rate-arbitrage && python -m pytest tests/ -x -q 2>&1 | tail -5
```
  </verify>
  <done>
Orchestrator has restart() for dashboard start/stop (DASH-04). RuntimeConfig overlay applied at cycle start (DASH-06). is_running property available. Existing behavior unchanged -- all existing tests pass.
  </done>
</task>

</tasks>

<verification>
1. `python -c "from bot.config import DashboardSettings, RuntimeConfig"` succeeds
2. `python -c "from bot.pnl.tracker import PnLTracker; t = PnLTracker.__new__(PnLTracker); print(hasattr(PnLTracker, 'get_closed_positions'))"` prints True
3. `python -c "from bot.orchestrator import Orchestrator; print(hasattr(Orchestrator, 'restart'))"` prints True
4. `python -m pytest tests/ -x -q` passes (no regressions)
</verification>

<success_criteria>
- DashboardSettings configurable via DASHBOARD_ env prefix
- RuntimeConfig dataclass allows non-None field overrides
- PnLTracker.get_closed_positions() returns closed positions sorted by close time
- PnLTracker.get_all_position_pnls() returns all positions for analytics
- PositionPnL has perp_symbol, spot_exit_price, perp_exit_price fields
- Orchestrator.restart() re-enters the run loop
- Orchestrator applies RuntimeConfig at each cycle start
- All existing tests pass without modification
</success_criteria>

<output>
After completion, create `.planning/phases/03-dashboard-analytics/03-02-SUMMARY.md`
</output>
