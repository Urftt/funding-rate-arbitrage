---
phase: 07-dynamic-position-sizing
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/bot/config.py
  - src/bot/position/dynamic_sizer.py
  - tests/test_position/test_dynamic_sizer.py
autonomous: true

must_haves:
  truths:
    - "A pair with a strong composite signal (score=0.9) gets a larger budget than a pair with a weak signal (score=0.3)"
    - "Budget is None when current portfolio exposure >= max_portfolio_exposure"
    - "DynamicSizer.calculate_matching_quantity calls PositionSizer.calculate_matching_quantity (delegation, not duplication)"
  artifacts:
    - path: "src/bot/position/dynamic_sizer.py"
      provides: "DynamicSizer class with compute_signal_budget and calculate_matching_quantity"
      exports: ["DynamicSizer"]
    - path: "src/bot/config.py"
      provides: "DynamicSizingSettings with SIZING_ env prefix"
      contains: "class DynamicSizingSettings"
    - path: "tests/test_position/test_dynamic_sizer.py"
      provides: "Tests proving SIZE-01, SIZE-02, SIZE-03"
      min_lines: 80
  key_links:
    - from: "src/bot/position/dynamic_sizer.py"
      to: "src/bot/position/sizing.py"
      via: "PositionSizer injected into DynamicSizer constructor, called in calculate_matching_quantity"
      pattern: "self\\._sizer\\.calculate_matching_quantity"
    - from: "src/bot/position/dynamic_sizer.py"
      to: "src/bot/config.py"
      via: "DynamicSizingSettings imported and used for allocation fractions and portfolio cap"
      pattern: "DynamicSizingSettings"
---

<objective>
Create the DynamicSizer class and DynamicSizingSettings config, proven through TDD.

Purpose: SIZE-01 (signal-conviction scaling), SIZE-02 (portfolio exposure cap), SIZE-03 (PositionSizer delegation) are the core requirements. The DynamicSizer is a thin wrapper: it maps a composite signal score to a USD budget, then delegates to the existing PositionSizer for exchange constraint validation.

Output: Tested DynamicSizer class ready for integration into orchestrator and backtest engine.
</objective>

<execution_context>
@/Users/luckleineschaars/.claude/get-shit-done/workflows/execute-plan.md
@/Users/luckleineschaars/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-dynamic-position-sizing/07-RESEARCH.md
@src/bot/config.py
@src/bot/position/sizing.py
@tests/test_position/test_sizing.py
</context>

<feature>
  <name>DynamicSizer: signal-conviction position sizing with portfolio cap</name>
  <files>src/bot/config.py, src/bot/position/dynamic_sizer.py, tests/test_position/test_dynamic_sizer.py</files>
  <behavior>
    DynamicSizer maps a composite signal score (Decimal, 0-1 range) and current portfolio exposure (Decimal, USD) to a position budget (Decimal | None).

    Formula: fraction = min_allocation_fraction + (max_allocation_fraction - min_allocation_fraction) * signal_score
    Raw budget = max_position_size_usd * fraction
    Effective budget = min(raw_budget, max_portfolio_exposure - current_exposure)
    If remaining budget <= 0: return None

    Cases for compute_signal_budget:
    - score=0.9, exposure=0, max_pos=1000, min_frac=0.3, max_frac=1.0 -> fraction=0.93, budget=930
    - score=0.3, exposure=0, max_pos=1000, min_frac=0.3, max_frac=1.0 -> fraction=0.51, budget=510
    - score=1.0, exposure=4500, cap=5000, max_pos=1000 -> remaining=500, budget=min(1000, 500)=500
    - score=1.0, exposure=5000, cap=5000 -> None (at cap)
    - score=0.0, exposure=0, max_pos=1000, min_frac=0.3 -> fraction=0.3, budget=300

    Cases for calculate_matching_quantity:
    - Calls PositionSizer.calculate_matching_quantity with effective_balance = min(available_balance, budget)
    - When budget is None -> returns None without calling PositionSizer

    DynamicSizingSettings:
    - enabled: bool = False (default off, preserves v1.0)
    - min_allocation_fraction: Decimal = 0.3
    - max_allocation_fraction: Decimal = 1.0
    - max_portfolio_exposure: Decimal = 5000
    - env prefix: SIZING_
    - Does NOT duplicate max_position_size_usd (reads from RiskSettings or TradingSettings)
  </behavior>
  <implementation>
    RED phase:
    1. Add DynamicSizingSettings to src/bot/config.py (below BacktestSettings, before RuntimeConfig). Fields: enabled (bool, False), min_allocation_fraction (Decimal, "0.3"), max_allocation_fraction (Decimal, "1.0"), max_portfolio_exposure (Decimal, "5000"). SettingsConfigDict with env_prefix="SIZING_". Add sizing: DynamicSizingSettings = DynamicSizingSettings() to AppSettings.

    2. Create tests/test_position/test_dynamic_sizer.py with:
       - Fixtures: DynamicSizingSettings with defaults, TradingSettings with max_position_size_usd=1000, PositionSizer from those settings, DynamicSizer wrapping both
       - TestSignalBudget class:
         - test_strong_signal_larger_than_weak: score=0.9 budget > score=0.3 budget (SIZE-01)
         - test_max_score_full_allocation: score=1.0 -> budget=max_position_size_usd * 1.0
         - test_min_score_min_allocation: score=0.0 -> budget=max_position_size_usd * 0.3
         - test_mid_score_linear_interpolation: score=0.5 -> fraction=0.65, budget=650
       - TestPortfolioCap class:
         - test_budget_none_at_cap: exposure=5000, cap=5000 -> None (SIZE-02)
         - test_budget_none_over_cap: exposure=6000, cap=5000 -> None
         - test_budget_capped_by_remaining: exposure=4500, cap=5000 -> budget=min(raw, 500)
         - test_zero_exposure_full_budget: exposure=0 -> full raw budget
       - TestDelegation class:
         - test_delegates_to_position_sizer: Mock PositionSizer, verify calculate_matching_quantity called (SIZE-03)
         - test_returns_none_when_budget_none: exposure=cap -> returns None, PositionSizer NOT called
         - test_effective_balance_is_min_of_balance_and_budget: verify passed balance is min(available, budget)

    3. Create src/bot/position/dynamic_sizer.py with DynamicSizer class stub (all methods raise NotImplementedError).

    4. Run tests -- all must FAIL (RED).

    GREEN phase:
    5. Implement DynamicSizer:
       - __init__(self, position_sizer: PositionSizer, settings: DynamicSizingSettings, max_position_size_usd: Decimal)
       - compute_signal_budget(self, signal_score: Decimal, current_exposure: Decimal) -> Decimal | None
       - calculate_matching_quantity(self, signal_score, current_exposure, price, available_balance, spot_instrument, perp_instrument) -> Decimal | None
       - All Decimal arithmetic, no float
       - structlog logging for budget decisions

    6. Run tests -- all must PASS (GREEN).

    REFACTOR: Clean up docstrings, ensure all type hints match.
  </implementation>
</feature>

<verification>
- `cd /Users/luckleineschaars/repos/funding-rate-arbitrage && python -m pytest tests/test_position/test_dynamic_sizer.py -v` -- all tests pass
- `cd /Users/luckleineschaars/repos/funding-rate-arbitrage && python -m pytest tests/ -x` -- no regressions
- `cd /Users/luckleineschaars/repos/funding-rate-arbitrage && python -c "from bot.position.dynamic_sizer import DynamicSizer; from bot.config import DynamicSizingSettings; print('imports OK')"` -- imports work
</verification>

<success_criteria>
- DynamicSizingSettings exists in config.py with SIZING_ prefix, 4 fields (enabled, min_allocation_fraction, max_allocation_fraction, max_portfolio_exposure), and is included in AppSettings
- DynamicSizer class exists with compute_signal_budget and calculate_matching_quantity methods
- Tests prove: strong signal > weak signal budget (SIZE-01), None at portfolio cap (SIZE-02), delegates to PositionSizer (SIZE-03)
- All existing tests still pass (no regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/07-dynamic-position-sizing/07-01-SUMMARY.md`
</output>
