---
phase: 07-dynamic-position-sizing
plan: 02
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - src/bot/orchestrator.py
  - src/bot/main.py
  - src/bot/backtest/engine.py
  - src/bot/backtest/models.py
autonomous: true

must_haves:
  truths:
    - "In composite mode with dynamic sizing enabled, orchestrator computes signal-adjusted budget and passes it as available_balance to open_position"
    - "Portfolio exposure is recomputed after each successful position open within the same cycle (no exceeding cap when opening multiple positions)"
    - "When dynamic sizing is disabled or strategy_mode is simple, existing static sizing behavior is unchanged"
    - "BacktestEngine in composite mode uses DynamicSizer when sizing params are provided in BacktestConfig"
  artifacts:
    - path: "src/bot/orchestrator.py"
      provides: "DynamicSizer integration in composite entry flow with portfolio exposure tracking"
      contains: "dynamic_sizer"
    - path: "src/bot/main.py"
      provides: "DynamicSizer creation and injection into orchestrator"
      contains: "DynamicSizer"
    - path: "src/bot/backtest/engine.py"
      provides: "DynamicSizer integration in composite backtest mode"
      contains: "dynamic_sizer"
    - path: "src/bot/backtest/models.py"
      provides: "Dynamic sizing parameters in BacktestConfig"
      contains: "sizing_enabled"
  key_links:
    - from: "src/bot/orchestrator.py"
      to: "src/bot/position/dynamic_sizer.py"
      via: "DynamicSizer injected as optional dependency, called in _open_profitable_positions_composite"
      pattern: "self\\._dynamic_sizer"
    - from: "src/bot/main.py"
      to: "src/bot/position/dynamic_sizer.py"
      via: "Creates DynamicSizer when sizing.enabled and strategy_mode==composite"
      pattern: "DynamicSizer\\("
    - from: "src/bot/backtest/engine.py"
      to: "src/bot/position/dynamic_sizer.py"
      via: "Creates DynamicSizer when config has sizing enabled in composite mode"
      pattern: "DynamicSizer\\("
    - from: "src/bot/orchestrator.py"
      to: "src/bot/models.py"
      via: "Reads Position.quantity and Position.perp_entry_price for exposure computation"
      pattern: "pos\\.quantity \\* pos\\.perp_entry_price"
---

<objective>
Wire DynamicSizer into the orchestrator composite flow, main.py component creation, and backtest engine.

Purpose: The DynamicSizer from Plan 01 is a standalone class. This plan connects it to the production orchestrator (live/paper trading) and the backtest engine so that signal-conviction sizing actually takes effect.

Output: Fully integrated dynamic sizing across orchestrator and backtest engine, with v1.0 behavior preserved when disabled.
</objective>

<execution_context>
@/Users/luckleineschaars/.claude/get-shit-done/workflows/execute-plan.md
@/Users/luckleineschaars/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-dynamic-position-sizing/07-RESEARCH.md
@.planning/phases/07-dynamic-position-sizing/07-01-SUMMARY.md
@src/bot/orchestrator.py
@src/bot/main.py
@src/bot/backtest/engine.py
@src/bot/backtest/models.py
@src/bot/position/dynamic_sizer.py
@src/bot/config.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire DynamicSizer into Orchestrator and main.py</name>
  <files>src/bot/orchestrator.py, src/bot/main.py</files>
  <action>
  Modify Orchestrator to accept and use DynamicSizer:

  1. In orchestrator.py:
     - Add TYPE_CHECKING import for DynamicSizer: `from bot.position.dynamic_sizer import DynamicSizer` (under TYPE_CHECKING block)
     - Add `dynamic_sizer: DynamicSizer | None = None` parameter to __init__ after signal_settings
     - Store as `self._dynamic_sizer = dynamic_sizer`
     - Add `_compute_current_exposure(self) -> Decimal` method: sum `pos.quantity * pos.perp_entry_price` for all open positions from `self._position_manager.get_open_positions()`. Return Decimal("0") if no positions.
     - Modify `_open_profitable_positions_composite()`:
       a. Before the loop, compute `current_exposure = self._compute_current_exposure()` (only if `self._dynamic_sizer is not None`, otherwise skip all dynamic sizing logic)
       b. Inside the loop, AFTER risk check passes and BEFORE calling `self.open_position()`:
          - If `self._dynamic_sizer is not None`:
            - Call `budget = self._dynamic_sizer.compute_signal_budget(signal_score=cs.signal.score, current_exposure=current_exposure)`
            - If budget is None: log "portfolio_exposure_cap_reached" with symbol and current_exposure, then `break` (no more budget for any pair)
            - Fetch available_balance: `balance_data = await self._exchange_client.fetch_balance(); free = Decimal(str(balance_data.get("USDT", {}).get("free", 0))); available_balance = min(free, budget)`
            - Pass `available_balance=available_balance` to `self.open_position(opp.spot_symbol, opp.perp_symbol, available_balance=available_balance)`
          - If `self._dynamic_sizer is None`: keep existing behavior (no available_balance override, existing `self.open_position(opp.spot_symbol, opp.perp_symbol)` call unchanged)
       c. After a successful position open (inside the try block, after the open_position call), if `self._dynamic_sizer is not None`:
          - Retrieve the position returned by open_position (already returns Position)
          - Update: `current_exposure += position.quantity * position.perp_entry_price`
       d. The existing logging for "composite_position_opened" stays. Add `signal_score=str(cs.signal.score)` and `budget=str(budget)` to the log kwargs when dynamic_sizer is active.

  Note: The `open_position` method on Orchestrator already accepts an optional `available_balance` parameter. When None, it fetches from exchange. When provided, it uses that value. So for the dynamic sizer path, compute and pass the budget-capped balance directly.

  IMPORTANT: When dynamic_sizer is None (disabled), the existing code path must be IDENTICAL to current behavior. Do not change any existing behavior -- only add the new code path gated on `self._dynamic_sizer is not None`.

  2. In main.py:
     - Import DynamicSizer: `from bot.position.dynamic_sizer import DynamicSizer`
     - Import DynamicSizingSettings is not needed -- it's already part of AppSettings via config.py (from Plan 01 which added `sizing: DynamicSizingSettings` to AppSettings)
     - After creating signal_engine (line ~168), add dynamic sizer creation:
       ```
       dynamic_sizer = None
       if settings.sizing.enabled and settings.trading.strategy_mode == "composite":
           dynamic_sizer = DynamicSizer(
               position_sizer=position_sizer,
               settings=settings.sizing,
               max_position_size_usd=settings.trading.max_position_size_usd,
           )
       ```
     - Pass `dynamic_sizer=dynamic_sizer` to the Orchestrator constructor
  </action>
  <verify>
  - `cd /Users/luckleineschaars/repos/funding-rate-arbitrage && python -c "from bot.orchestrator import Orchestrator; print('orchestrator imports OK')"`
  - `cd /Users/luckleineschaars/repos/funding-rate-arbitrage && python -c "from bot.main import _build_components; print('main imports OK')"`
  - `cd /Users/luckleineschaars/repos/funding-rate-arbitrage && python -m pytest tests/ -x --timeout=30` -- no regressions
  </verify>
  <done>
  - Orchestrator accepts `dynamic_sizer: DynamicSizer | None = None`
  - `_compute_current_exposure()` method returns Decimal sum of open position notionals
  - `_open_profitable_positions_composite()` uses DynamicSizer when available: computes budget, caps available_balance, updates exposure after each open
  - When `dynamic_sizer` is None, all behavior is unchanged from current code
  - main.py creates DynamicSizer when `settings.sizing.enabled and strategy_mode == "composite"`, injects into Orchestrator
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire DynamicSizer into BacktestEngine and BacktestConfig</name>
  <files>src/bot/backtest/models.py, src/bot/backtest/engine.py</files>
  <action>
  1. In backtest/models.py (BacktestConfig):
     - Add dynamic sizing fields after the existing composite strategy params:
       ```python
       # Dynamic sizing params (Phase 7)
       sizing_enabled: bool = False
       sizing_min_allocation_fraction: Decimal = Decimal("0.3")
       sizing_max_allocation_fraction: Decimal = Decimal("1.0")
       sizing_max_portfolio_exposure: Decimal = Decimal("5000")
       ```
     - Add these to `to_dict()` method
     - Add a `to_sizing_settings()` method that returns a DynamicSizingSettings:
       ```python
       def to_sizing_settings(self) -> "DynamicSizingSettings":
           from bot.config import DynamicSizingSettings
           return DynamicSizingSettings(
               enabled=self.sizing_enabled,
               min_allocation_fraction=self.sizing_min_allocation_fraction,
               max_allocation_fraction=self.sizing_max_allocation_fraction,
               max_portfolio_exposure=self.sizing_max_portfolio_exposure,
           )
       ```

  2. In backtest/engine.py:
     - Import DynamicSizer: `from bot.position.dynamic_sizer import DynamicSizer`
     - After creating `self._signal_engine` in __init__, add DynamicSizer creation:
       ```python
       self._dynamic_sizer: DynamicSizer | None = None
       if config.strategy_mode == "composite" and config.sizing_enabled:
           self._dynamic_sizer = DynamicSizer(
               position_sizer=self._position_sizer,
               settings=config.to_sizing_settings(),
               max_position_size_usd=config.initial_capital,
           )
       ```
     - Modify the position open section (step j, around line 323) to use dynamic sizing when available:
       In the `if should_open and not has_open_position:` block:
       a. Default `available_balance = self._config.initial_capital` (existing behavior)
       b. If `self._dynamic_sizer is not None`:
          - Get the composite signal score. This requires access to the score from the composite decision. Modify `_composite_decision` to return the signal score as well: change return type to `tuple[bool, bool, Decimal | None]` where the third element is the signal score (or None for simple fallback).
          - Actually, cleaner approach: store the last composite score on self as `self._last_signal_score: Decimal | None = None` (set in `_composite_decision` when a valid score is computed, reset to None otherwise).
          - In _composite_decision, when scores are available and should_open is True: `self._last_signal_score = signal.score`
          - In the position open block: if `self._dynamic_sizer is not None and self._last_signal_score is not None`:
            - Compute `current_exposure = self._compute_current_exposure()` (add this helper method, same pattern as orchestrator: sum pos.quantity * pos.perp_entry_price for open positions)
            - `budget = self._dynamic_sizer.compute_signal_budget(self._last_signal_score, current_exposure)`
            - If budget is None: skip open (log "backtest_portfolio_cap_reached"), set should_open = False
            - Else: `available_balance = min(self._config.initial_capital, budget)`
       c. Use this `available_balance` in the existing `open_position` call (replace the hardcoded `self._config.initial_capital`)

     - Add `_compute_current_exposure(self) -> Decimal` helper:
       ```python
       def _compute_current_exposure(self) -> Decimal:
           total = Decimal("0")
           for pos in self._position_manager.get_open_positions():
               total += pos.quantity * pos.perp_entry_price
           return total
       ```

     IMPORTANT: When `self._dynamic_sizer is None` (sizing disabled or simple mode), the existing behavior must be IDENTICAL. The backtest currently uses `self._config.initial_capital` as available_balance -- that stays as the default.

     NOTE: The backtest engine currently handles single-symbol backtests (one position at a time). Dynamic sizing still matters because: (a) signal score affects position SIZE even for a single position, and (b) the portfolio cap prevents reopening if exposure tracking shows it's at the limit. The `has_open_position` flag already prevents multiple simultaneous positions, but sizing the single position by conviction is the key SIZE-01 behavior.
  </action>
  <verify>
  - `cd /Users/luckleineschaars/repos/funding-rate-arbitrage && python -c "from bot.backtest.engine import BacktestEngine; print('engine imports OK')"`
  - `cd /Users/luckleineschaars/repos/funding-rate-arbitrage && python -c "from bot.backtest.models import BacktestConfig; c = BacktestConfig(symbol='BTC/USDT:USDT', start_ms=0, end_ms=1); print(c.sizing_enabled, c.to_sizing_settings()); print('models OK')"`
  - `cd /Users/luckleineschaars/repos/funding-rate-arbitrage && python -m pytest tests/ -x --timeout=30` -- no regressions
  </verify>
  <done>
  - BacktestConfig has sizing_enabled, sizing_min_allocation_fraction, sizing_max_allocation_fraction, sizing_max_portfolio_exposure fields
  - BacktestConfig.to_sizing_settings() returns DynamicSizingSettings
  - BacktestEngine creates DynamicSizer when config.sizing_enabled and composite mode
  - Backtest position opens use signal-adjusted budget when DynamicSizer is active
  - When sizing disabled, backtest behavior is identical to current (initial_capital as available_balance)
  - All existing tests pass
  </done>
</task>

</tasks>

<verification>
- All tests pass: `cd /Users/luckleineschaars/repos/funding-rate-arbitrage && python -m pytest tests/ -v --timeout=60`
- Import chain works: `python -c "from bot.main import _build_components; from bot.orchestrator import Orchestrator; from bot.backtest.engine import BacktestEngine; print('all imports OK')"`
- DynamicSizer is optional in orchestrator: grep for `dynamic_sizer: DynamicSizer | None = None` in orchestrator.py
- Existing v1.0 path untouched: grep for `strategy_mode == "composite"` gates in orchestrator.py and engine.py
</verification>

<success_criteria>
- Orchestrator uses DynamicSizer in composite mode: computes budget from signal score, passes capped available_balance to open_position, recomputes exposure after each open
- main.py creates DynamicSizer when sizing.enabled AND strategy_mode=="composite", injects into Orchestrator
- BacktestEngine uses DynamicSizer in composite mode with sizing enabled: signal-adjusted position opens
- BacktestConfig has dynamic sizing parameters with to_sizing_settings() method
- When dynamic sizing is disabled (default): all behavior unchanged from Phase 6 baseline
- All existing tests pass with no regressions
</success_criteria>

<output>
After completion, create `.planning/phases/07-dynamic-position-sizing/07-02-SUMMARY.md`
</output>
