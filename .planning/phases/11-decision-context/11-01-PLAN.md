---
phase: 11-decision-context
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/bot/analytics/decision_engine.py
  - src/bot/dashboard/routes/api.py
  - src/bot/dashboard/app.py
  - src/bot/main.py
autonomous: true

must_haves:
  truths:
    - "DecisionEngine computes rate percentile, trend, signal breakdown, and action label for any tracked pair"
    - "API endpoint GET /api/decision/{symbol} returns complete DecisionContext JSON"
    - "API endpoint GET /api/decision/summary returns decision contexts for all pairs with live funding rates"
    - "DecisionEngine caches results with TTL to avoid redundant computation"
    - "Graceful degradation when SignalEngine or FundingMonitor unavailable"
  artifacts:
    - path: "src/bot/analytics/decision_engine.py"
      provides: "DecisionEngine service with RateContext, SignalBreakdown, ActionLabel, DecisionContext dataclasses"
      exports: ["DecisionEngine", "DecisionContext", "RateContext", "SignalBreakdown", "ActionLabel"]
    - path: "src/bot/dashboard/routes/api.py"
      provides: "GET /api/decision/{symbol} and GET /api/decision/summary endpoints"
      contains: "get_decision_context"
    - path: "src/bot/dashboard/app.py"
      provides: "app.state.decision_engine placeholder"
      contains: "decision_engine"
    - path: "src/bot/main.py"
      provides: "DecisionEngine wiring in lifespan"
      contains: "DecisionEngine"
  key_links:
    - from: "src/bot/analytics/decision_engine.py"
      to: "src/bot/analytics/pair_analyzer.py"
      via: "PairAnalyzer.get_pair_stats() for historical rates and sorted values"
      pattern: "pair_analyzer.*get_pair_stats\\|get_funding_rates"
    - from: "src/bot/analytics/decision_engine.py"
      to: "src/bot/signals/engine.py"
      via: "SignalEngine for composite signal breakdown (optional)"
      pattern: "signal_engine"
    - from: "src/bot/dashboard/routes/api.py"
      to: "src/bot/analytics/decision_engine.py"
      via: "app.state.decision_engine.get_decision_context()"
      pattern: "decision_engine.*get_decision_context"
    - from: "src/bot/main.py"
      to: "src/bot/analytics/decision_engine.py"
      via: "DecisionEngine instantiation with pair_analyzer, signal_engine, funding_monitor"
      pattern: "DecisionEngine\\("
---

<objective>
Create the DecisionEngine backend service that computes rate percentiles, signal breakdowns, and action labels for each trading pair, plus expose via API endpoints.

Purpose: This is the data foundation for Phase 11. All decision context features (percentile badges, trend arrows, action labels, summary page) depend on having a backend service that bridges PairAnalyzer (historical stats), SignalEngine (composite signals), and FundingMonitor (live rates) into structured DecisionContext objects.

Output: DecisionEngine service class with dataclasses, two API endpoints, and wiring in main.py/app.py.
</objective>

<execution_context>
@/Users/luckleineschaars/.claude/get-shit-done/workflows/execute-plan.md
@/Users/luckleineschaars/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-decision-context/11-RESEARCH.md
@src/bot/analytics/pair_analyzer.py
@src/bot/signals/models.py
@src/bot/signals/engine.py
@src/bot/dashboard/routes/api.py
@src/bot/dashboard/app.py
@src/bot/main.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: DecisionEngine service with dataclasses and computation logic</name>
  <files>src/bot/analytics/decision_engine.py</files>
  <action>
Create `src/bot/analytics/decision_engine.py` with the following components:

**Dataclasses** (all using Decimal, with `to_dict()` methods serializing Decimal as strings):

1. `RateContext` -- historical context for a current funding rate:
   - `current_rate: Decimal` -- the live rate
   - `percentile: Decimal` -- 0-100 where current rate sits historically
   - `trend: TrendDirection` -- RISING / STABLE / FALLING (from `bot.signals.models`)
   - `avg_rate: Decimal` -- historical average
   - `median_rate: Decimal` -- historical median
   - `std_dev: Decimal` -- historical standard deviation
   - `is_above_average: bool` -- current_rate > avg_rate
   - `z_score: Decimal` -- (current - avg) / std_dev (use Decimal("0") if std_dev is zero)

2. `SignalBreakdown` -- sub-signal contributions for display:
   - `composite_score: Decimal` -- 0-1 total score
   - `rate_level: Decimal` -- normalized rate contribution
   - `trend_score: Decimal` -- trend contribution
   - `persistence: Decimal` -- persistence contribution
   - `basis_score: Decimal` -- basis contribution
   - `volume_ok: bool` -- volume filter pass/fail
   - `weights: dict[str, str]` -- weight configuration (Decimal values as strings)

3. `ActionLabel`:
   - `label: str` -- "Strong opportunity", "Moderate opportunity", "Below average", "Not recommended", or "Insufficient data"
   - `confidence: str` -- "high", "medium", "low"
   - `reasons: list[str]` -- evidence-based reasons

4. `DecisionContext`:
   - `symbol: str`
   - `rate_context: RateContext`
   - `signal_breakdown: SignalBreakdown | None` -- None if signal engine unavailable
   - `action: ActionLabel`
   - `has_sufficient_data: bool`

**Module-level functions:**

1. `compute_rate_percentile(current_rate: Decimal, sorted_rates: list[Decimal]) -> Decimal`:
   - Use `bisect.bisect_left` on sorted list.
   - Return `(position / n) * 100`, quantized to `Decimal("0.1")`.
   - Return `Decimal("50.0")` if sorted_rates is empty.

2. `classify_action(percentile, composite_score, has_sufficient_data, trend) -> ActionLabel`:
   - If not `has_sufficient_data`: return "Insufficient data" / low confidence.
   - Thresholds: Strong >= P75 AND trend != FALLING AND (score >= 0.5 or None); Moderate >= P50 AND (score >= 0.4 or None); Below average >= P25; else Not recommended.
   - Build reasons list from evidence (percentile position, trend direction, composite score level).

**DecisionEngine class:**

Constructor takes: `pair_analyzer: PairAnalyzer`, `signal_engine: SignalEngine | None = None`, `funding_monitor: FundingMonitor | None = None`, `data_store: HistoricalDataStore | None = None`, `cache_ttl_seconds: int = 120`.

Use `_cache: dict[str, tuple[float, DecisionContext]]` with TTL pattern (same as `MarketCapService`).

Method `async get_decision_context(self, symbol: str, since_ms: int | None = None) -> DecisionContext`:
1. Check cache by key `f"{symbol}:{since_ms}"`. Return cached if fresh.
2. Get `PairStats` via `pair_analyzer.get_pair_stats(symbol, since_ms)` for avg_rate, median_rate, std_dev, has_sufficient_data.
3. Get historical rates via `data_store.get_funding_rates(symbol, since_ms)` for sorted rate values.
4. Get current live rate from `funding_monitor.get_all_funding_rates()` filtered to symbol. If no live rate, use avg_rate as fallback.
5. Compute percentile via `compute_rate_percentile(current_rate, sorted_rates)`.
6. Get trend by calling `classify_trend()` from `bot.signals.trend` on recent rate values (last `30` values). Default to STABLE if insufficient data.
7. Compute z_score: `(current_rate - avg_rate) / std_dev` if std_dev > 0, else `Decimal("0")`.
8. Build `RateContext`.
9. If `signal_engine` available, try to build `SignalBreakdown` from a `CompositeSignal` by calling `signal_engine._compute_signal()` -- wrap in try/except, set to None on failure. Extract sub-signal values from the CompositeSignal fields. NOTE: Since `_compute_signal` is internal, instead access the signal engine's scoring via `score_opportunities()` or `score_for_exit()` with the current funding rate data. Use `score_for_exit([symbol], funding_rates, markets)` if funding_monitor has markets data. If markets dict not available, skip signal breakdown.
   - **Simpler approach:** Since getting markets dict from the exchange client in the DecisionEngine would add coupling, make SignalBreakdown optional and populate it only when a pre-computed CompositeSignal is available. Add a `set_latest_signals(signals: dict[str, CompositeSignal])` method that the update loop can call to provide fresh signal data. The DecisionEngine reads from this dict when building context.
10. Classify action via `classify_action()`.
11. Build and cache `DecisionContext`.

Method `async get_all_decision_contexts(self, since_ms: int | None = None) -> dict[str, DecisionContext]`:
1. Get all live funding rates from `funding_monitor.get_all_funding_rates()`.
2. For each symbol (up to 30), call `get_decision_context(symbol, since_ms)` with try/except per pair.
3. Return dict mapping symbol -> DecisionContext.

Method `set_latest_signals(self, signals: dict[str, CompositeSignal]) -> None`:
- Store as `self._latest_signals`. Used by update loop to pass pre-computed signal data.

Use TYPE_CHECKING import for FundingMonitor, HistoricalDataStore, SignalEngine to avoid circular imports (same pattern as signal engine).

Import `bisect` (stdlib), `time` (stdlib), `structlog`.
  </action>
  <verify>
Run `python -c "from bot.analytics.decision_engine import DecisionEngine, DecisionContext, RateContext, SignalBreakdown, ActionLabel, compute_rate_percentile, classify_action; print('imports OK')"` from the src directory.

Run `python -c "from bot.analytics.decision_engine import compute_rate_percentile; from decimal import Decimal; result = compute_rate_percentile(Decimal('0.0005'), [Decimal(str(i/10000)) for i in range(1, 101)]); print(f'Percentile: {result}')"` to verify percentile computation.
  </verify>
  <done>
DecisionEngine class exists with all 4 dataclasses (RateContext, SignalBreakdown, ActionLabel, DecisionContext), each with to_dict() methods. compute_rate_percentile uses bisect correctly. classify_action produces correct labels for all 4 threshold tiers plus "Insufficient data". DecisionEngine has get_decision_context, get_all_decision_contexts, and set_latest_signals methods. TTL caching implemented. All imports resolve.
  </done>
</task>

<task type="auto">
  <name>Task 2: API endpoints and app/main wiring for DecisionEngine</name>
  <files>
    src/bot/dashboard/routes/api.py
    src/bot/dashboard/app.py
    src/bot/main.py
  </files>
  <action>
**In `src/bot/dashboard/routes/api.py`**, add a Phase 11 section after the Phase 10 market-cap endpoints:

1. `GET /api/decision/{symbol:path}` endpoint (`get_decision_context_endpoint`):
   - Get `decision_engine` from `request.app.state` via `getattr(..., None)`.
   - Return 501 if None.
   - Accept `range` query param (default "all"), convert via existing `_range_to_since_ms()`.
   - Call `await decision_engine.get_decision_context(symbol, since_ms=since_ms)`.
   - Return `JSONResponse(content=context.to_dict())`.
   - Wrap in try/except, return 500 on error.

2. `GET /api/decision/summary` endpoint (`get_decision_summary`):
   - IMPORTANT: Register this route BEFORE the `{symbol:path}` route so FastAPI matches it first. Otherwise "summary" gets captured as a symbol.
   - Get `decision_engine` from `request.app.state`.
   - Return 501 if None.
   - Accept `range` query param.
   - Call `await decision_engine.get_all_decision_contexts(since_ms=since_ms)`.
   - Return dict of `{symbol: context.to_dict()}` for each pair.
   - Wrap in try/except.

**In `src/bot/dashboard/app.py`**, add after the market_cap_service placeholder:
```python
# Decision engine for decision context (Phase 11) -- wired by main.py lifespan
app.state.decision_engine = None
```

**In `src/bot/main.py`**, add wiring in the lifespan function after the market_cap_service wiring:

1. Import `DecisionEngine` from `bot.analytics.decision_engine` at the top of the file.
2. In the lifespan, after the `app.state.market_cap_service` line:
```python
# Wire decision engine for decision context (Phase 11)
if components.get("data_store") is not None:
    app.state.decision_engine = DecisionEngine(
        pair_analyzer=app.state.pair_analyzer,
        signal_engine=components.get("signal_engine"),
        funding_monitor=components.get("funding_monitor"),
        data_store=components.get("data_store"),
    )
```

This ensures DecisionEngine is only created when historical data is available (same guard as PairAnalyzer).
  </action>
  <verify>
Run `python -c "from bot.dashboard.routes.api import router; print('API imports OK')"` from the src directory.

Run `python -c "from bot.dashboard.app import create_dashboard_app; app = create_dashboard_app(); print('decision_engine' in dir(app.state))"` -- should print True.

Run `python -c "from bot.main import main; print('main imports OK')"` from the src directory.

Verify no existing tests break: `cd /Users/luckleineschaars/repos/funding-rate-arbitrage && python -m pytest tests/ -x -q 2>&1 | tail -5`
  </verify>
  <done>
GET /api/decision/summary returns decision contexts for all pairs with live rates. GET /api/decision/{symbol} returns decision context for a specific pair. app.state.decision_engine placeholder exists in app.py. main.py wires DecisionEngine when data_store is available. All existing tests pass.
  </done>
</task>

</tasks>

<verification>
1. `python -c "from bot.analytics.decision_engine import DecisionEngine, DecisionContext, compute_rate_percentile, classify_action"` succeeds
2. `python -m pytest tests/ -x -q` passes with no regressions
3. API endpoints accessible: `GET /api/decision/summary` and `GET /api/decision/{symbol}`
4. DecisionEngine wired in main.py lifespan when data_store available
</verification>

<success_criteria>
- DecisionEngine service computes rate percentile (via bisect), trend, optional signal breakdown, and action label for any pair
- Two API endpoints serve decision context as JSON
- Caching with TTL prevents redundant computation
- Graceful degradation when signal engine or funding monitor unavailable
- All existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/11-decision-context/11-01-SUMMARY.md`
</output>
