---
phase: 05-signal-analysis-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/bot/signals/__init__.py
  - src/bot/signals/models.py
  - src/bot/signals/trend.py
  - src/bot/signals/persistence.py
  - src/bot/config.py
autonomous: true

must_haves:
  truths:
    - "TrendDirection enum classifies funding rate trend as RISING, FALLING, or STABLE"
    - "compute_ema returns EMA values using Decimal arithmetic with quantize for precision management"
    - "classify_trend gracefully returns STABLE when insufficient historical data (< span+1 records)"
    - "compute_persistence_score counts consecutive elevated periods and normalizes to 0-1 range"
    - "SignalSettings provides configurable EMA span, thresholds, weights, and lookback periods"
    - "strategy_mode field on TradingSettings defaults to 'simple' preserving v1.0 behavior"
  artifacts:
    - path: "src/bot/signals/__init__.py"
      provides: "Package exports for signal module public API"
    - path: "src/bot/signals/models.py"
      provides: "TrendDirection enum, CompositeSignal dataclass, CompositeOpportunityScore dataclass"
      contains: "class TrendDirection"
    - path: "src/bot/signals/trend.py"
      provides: "compute_ema and classify_trend functions"
      exports: ["compute_ema", "classify_trend"]
    - path: "src/bot/signals/persistence.py"
      provides: "compute_persistence_score function"
      exports: ["compute_persistence_score"]
    - path: "src/bot/config.py"
      provides: "SignalSettings class and strategy_mode on TradingSettings"
      contains: "class SignalSettings"
  key_links:
    - from: "src/bot/signals/trend.py"
      to: "src/bot/signals/models.py"
      via: "imports TrendDirection"
      pattern: "from bot\\.signals\\.models import TrendDirection"
    - from: "src/bot/config.py"
      to: "src/bot/signals/"
      via: "SignalSettings referenced by engine and main.py in later plans"
      pattern: "class SignalSettings"
---

<objective>
Create the signal analysis data models, configuration, and two core sub-signal computation modules: trend detection (SGNL-01) and persistence scoring (SGNL-02).

Purpose: Establishes the type system and pure computation functions that all other signal plans depend on. The trend detector uses EMA to classify funding rate direction; the persistence scorer quantifies how long a rate has stayed elevated. Both degrade gracefully with insufficient data.

Output: `src/bot/signals/` package with models, trend, and persistence modules; `SignalSettings` config class; `strategy_mode` field on `TradingSettings`.
</objective>

<execution_context>
@/Users/luckleineschaars/.claude/get-shit-done/workflows/execute-plan.md
@/Users/luckleineschaars/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-signal-analysis-integration/05-RESEARCH.md
@src/bot/config.py
@src/bot/models.py
@src/bot/data/models.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Signal data models, config, and package init</name>
  <files>
    src/bot/signals/__init__.py
    src/bot/signals/models.py
    src/bot/config.py
  </files>
  <action>
Create the `src/bot/signals/` package directory.

**src/bot/signals/models.py:**

Create signal data models using dataclasses and Decimal (project convention):

1. `TrendDirection(str, Enum)` with values RISING, FALLING, STABLE -- mirrors the pattern of `OrderSide`, `OrderType`, `PositionSide` in `src/bot/models.py`.

2. `CompositeSignal` dataclass with fields:
   - `symbol: str` -- the perp symbol
   - `score: Decimal` -- weighted composite score (0-1 range)
   - `rate_level: Decimal` -- normalized current funding rate (0-1)
   - `trend: TrendDirection` -- direction classification
   - `trend_score: Decimal` -- numeric trend contribution (0-1)
   - `persistence: Decimal` -- persistence score (0-1)
   - `basis_spread: Decimal` -- raw basis spread value
   - `basis_score: Decimal` -- normalized basis contribution (0-1)
   - `volume_ok: bool` -- passes volume filter
   - `passes_entry: bool` -- composite score >= entry threshold AND volume_ok

3. `CompositeOpportunityScore` dataclass that wraps the existing `OpportunityScore` for orchestrator compatibility. Fields:
   - `opportunity: OpportunityScore` -- the v1.0-compatible score (reuse existing type)
   - `signal: CompositeSignal` -- the composite signal breakdown
   This allows the orchestrator's `_open_profitable_positions` to access `.opportunity.spot_symbol`, `.opportunity.perp_symbol`, etc. while also having the composite signal data.

**src/bot/config.py:**

Add `SignalSettings(BaseSettings)` with `env_prefix="SIGNAL_"`:
- `trend_ema_span: int = 6` -- number of funding periods for EMA
- `trend_stable_threshold: Decimal = Decimal("0.00005")` -- min EMA diff for rising/falling
- `persistence_threshold: Decimal = Decimal("0.0003")` -- rate threshold for "elevated"
- `persistence_max_periods: int = 30` -- normalize count against this
- `basis_weight_cap: Decimal = Decimal("0.01")` -- cap basis contribution at 1%
- `volume_lookback_days: int = 7` -- days for recent volume average
- `volume_decline_ratio: Decimal = Decimal("0.7")` -- flag if recent < 70% of prior
- `weight_rate_level: Decimal = Decimal("0.35")` -- rate level weight
- `weight_trend: Decimal = Decimal("0.25")` -- trend weight
- `weight_persistence: Decimal = Decimal("0.25")` -- persistence weight
- `weight_basis: Decimal = Decimal("0.15")` -- basis weight
- `entry_threshold: Decimal = Decimal("0.5")` -- min composite score to enter
- `exit_threshold: Decimal = Decimal("0.3")` -- close when score drops below
- `rate_normalization_cap: Decimal = Decimal("0.003")` -- cap for normalizing funding rate to 0-1 (rates above this get score 1.0)

Add `strategy_mode: Literal["simple", "composite"] = "simple"` to the existing `TradingSettings` class. Default "simple" preserves all v1.0 behavior.

Add `signal: SignalSettings = SignalSettings()` to `AppSettings`.

**src/bot/signals/__init__.py:**

Export the models created in this task. Use `__all__` list. Only export what exists now (models); later plans will update this file to add more exports.

```python
from bot.signals.models import CompositeOpportunityScore, CompositeSignal, TrendDirection

__all__ = [
    "CompositeOpportunityScore",
    "CompositeSignal",
    "TrendDirection",
]
```
  </action>
  <verify>
Run `python -c "from bot.signals.models import TrendDirection, CompositeSignal, CompositeOpportunityScore; from bot.config import SignalSettings, AppSettings; s = AppSettings(); print(s.trading.strategy_mode, s.signal.trend_ema_span)"` -- should print "simple 6".
Run existing tests: `python -m pytest tests/ -x -q` -- all must pass (strategy_mode defaults to "simple", no behavior change).
  </verify>
  <done>
TrendDirection enum, CompositeSignal, and CompositeOpportunityScore dataclasses exist. SignalSettings config class exists with all configurable fields. strategy_mode on TradingSettings defaults to "simple". All existing tests pass unchanged.
  </done>
</task>

<task type="auto">
  <name>Task 2: Trend detection and persistence scoring modules</name>
  <files>
    src/bot/signals/trend.py
    src/bot/signals/persistence.py
    tests/test_signals/__init__.py
    tests/test_signals/test_trend.py
    tests/test_signals/test_persistence.py
  </files>
  <action>
**src/bot/signals/trend.py:**

Implement two public functions following the research patterns exactly:

1. `compute_ema(values: list[Decimal], span: int) -> list[Decimal]`:
   - Standard recursive EMA: `alpha = Decimal("2") / (Decimal(span) + Decimal("1"))`, `EMA_t = alpha * value_t + (1 - alpha) * EMA_{t-1}`
   - First EMA value = first input value (standard initialization)
   - Use `.quantize(Decimal("0.000000000001"))` (12 decimal places) on each intermediate result to prevent Decimal precision explosion (research Pitfall #1)
   - Return empty list if input is empty

2. `classify_trend(funding_rates: list[Decimal], span: int = 6, stable_threshold: Decimal = Decimal("0.00005")) -> TrendDirection`:
   - If `len(funding_rates) < span + 1`: return `TrendDirection.STABLE` (graceful degradation per research Pitfall #2)
   - Compute EMA over funding_rates
   - Compare `ema[-1]` vs `ema[-span]`
   - diff > stable_threshold -> RISING
   - diff < -stable_threshold -> FALLING
   - Otherwise -> STABLE

**src/bot/signals/persistence.py:**

Implement one public function:

1. `compute_persistence_score(funding_rates: list[Decimal], threshold: Decimal, max_periods: int = 30) -> Decimal`:
   - Walk backward from most recent rate, count consecutive periods where `rate >= threshold`
   - Break on first rate below threshold
   - Return `min(Decimal(consecutive) / Decimal(max_periods), Decimal("1"))` capped at 1.0
   - Return `Decimal("0")` if funding_rates is empty

**Tests:**

Create `tests/test_signals/` package with `__init__.py`.

`tests/test_signals/test_trend.py`:
- Test compute_ema with known values (e.g., [1, 2, 3, 4, 5] with span=3, verify first few EMA values)
- Test compute_ema with empty list returns []
- Test compute_ema with single value returns [that value]
- Test classify_trend returns RISING for steadily increasing rates
- Test classify_trend returns FALLING for steadily decreasing rates
- Test classify_trend returns STABLE for flat rates
- Test classify_trend returns STABLE when insufficient data (< span+1)
- Test EMA values use quantize (result Decimals have bounded precision)

`tests/test_signals/test_persistence.py`:
- Test all rates above threshold -> persistence = min(count/max_periods, 1)
- Test last N rates above threshold, then one below -> consecutive count = N
- Test no rates above threshold -> persistence = 0
- Test empty list -> persistence = 0
- Test capping at Decimal("1") when consecutive > max_periods

All test values use Decimal (project convention). Use exact assertions like `assert result == Decimal("0.1")`.
  </action>
  <verify>
Run `python -m pytest tests/test_signals/ -v` -- all new tests pass.
Run `python -m pytest tests/ -x -q` -- all existing tests also pass.
Run `python -c "from bot.signals.trend import compute_ema, classify_trend; from bot.signals.persistence import compute_persistence_score; print('OK')"` -- prints OK.
  </verify>
  <done>
compute_ema and classify_trend work with Decimal precision and graceful degradation. compute_persistence_score counts consecutive elevated periods. All functions tested with >5 test cases each. All existing tests unaffected.
  </done>
</task>

</tasks>

<verification>
1. `python -m pytest tests/ -x -q` -- all tests pass (existing + new)
2. `python -c "from bot.signals import TrendDirection, CompositeSignal; print(TrendDirection.RISING.value)"` -- prints "rising"
3. `python -c "from bot.config import AppSettings; s = AppSettings(); print(s.trading.strategy_mode)"` -- prints "simple"
4. Verify no float usage in any new file: `grep -r "float(" src/bot/signals/` should return nothing
</verification>

<success_criteria>
- signals/ package exists with models.py, trend.py, persistence.py
- TrendDirection enum with RISING/FALLING/STABLE values
- CompositeSignal and CompositeOpportunityScore dataclasses defined
- SignalSettings in config.py with all signal parameters
- strategy_mode on TradingSettings defaults to "simple"
- compute_ema uses Decimal with quantize, returns correct EMA series
- classify_trend degrades to STABLE on insufficient data
- compute_persistence_score returns 0-1 normalized count
- New tests pass, existing tests unaffected
</success_criteria>

<output>
After completion, create `.planning/phases/05-signal-analysis-integration/05-01-SUMMARY.md`
</output>
