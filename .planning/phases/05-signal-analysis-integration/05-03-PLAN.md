---
phase: 05-signal-analysis-integration
plan: 03
type: execute
wave: 2
depends_on: ["05-01", "05-02"]
files_modified:
  - src/bot/signals/composite.py
  - src/bot/signals/engine.py
  - src/bot/signals/__init__.py
  - src/bot/orchestrator.py
  - src/bot/main.py
  - tests/test_signals/test_composite.py
  - tests/test_signals/test_engine.py
  - tests/test_orchestrator.py
autonomous: true

must_haves:
  truths:
    - "compute_composite_score produces a weighted sum of sub-signal scores using configurable weights"
    - "SignalEngine.score_opportunities fetches historical data, computes all sub-signals, and returns ranked CompositeOpportunityScores"
    - "SignalEngine degrades gracefully when historical data is unavailable (returns scores based on available signals only)"
    - "Orchestrator uses SignalEngine for entry AND exit decisions when strategy_mode is 'composite'"
    - "Orchestrator uses OpportunityRanker for entry AND exit decisions when strategy_mode is 'simple' (v1.0 behavior unchanged)"
    - "Composite signal breakdown is logged at INFO level on each scan cycle (SGNL-06 visibility)"
    - "All existing orchestrator tests pass unchanged (they run in 'simple' mode by default)"
  artifacts:
    - path: "src/bot/signals/composite.py"
      provides: "compute_composite_score and normalize_rate_level functions"
      exports: ["compute_composite_score", "normalize_rate_level"]
    - path: "src/bot/signals/engine.py"
      provides: "SignalEngine class with async score_opportunities method"
      exports: ["SignalEngine"]
    - path: "src/bot/signals/__init__.py"
      provides: "Complete public API for signals module"
    - path: "src/bot/orchestrator.py"
      provides: "strategy_mode branching for entry and exit decisions"
      contains: "strategy_mode"
    - path: "src/bot/main.py"
      provides: "SignalEngine wiring into component graph"
      contains: "signal_engine"
  key_links:
    - from: "src/bot/signals/engine.py"
      to: "src/bot/data/store.py"
      via: "async calls to get_funding_rates and get_ohlcv_candles"
      pattern: "data_store\\.get_funding_rates"
    - from: "src/bot/signals/engine.py"
      to: "src/bot/market_data/ticker_service.py"
      via: "get_price for spot/perp prices for basis computation"
      pattern: "ticker_service\\.get_price"
    - from: "src/bot/orchestrator.py"
      to: "src/bot/signals/engine.py"
      via: "conditional call to score_opportunities in composite mode"
      pattern: "signal_engine\\.score_opportunities"
    - from: "src/bot/main.py"
      to: "src/bot/signals/engine.py"
      via: "creates and injects SignalEngine into Orchestrator"
      pattern: "SignalEngine"
---

<objective>
Build the composite signal aggregator (SGNL-03), the SignalEngine that orchestrates all sub-signals (SGNL-06), and wire everything into the orchestrator with the strategy_mode feature flag.

Purpose: This is the integration plan that turns the individual sub-signal modules from Plans 01 and 02 into a complete composite scoring pipeline, replaces the simple threshold in the orchestrator for entry AND exit decisions when strategy_mode is "composite", and preserves v1.0 behavior when strategy_mode is "simple". This completes all 6 SGNL requirements.

Output: Complete signal analysis pipeline from data to decision. The bot can now make entry/exit decisions based on composite signals (trend + persistence + basis + volume) or revert to simple thresholds via config.
</objective>

<execution_context>
@/Users/luckleineschaars/.claude/get-shit-done/workflows/execute-plan.md
@/Users/luckleineschaars/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-signal-analysis-integration/05-RESEARCH.md
@.planning/phases/05-signal-analysis-integration/05-01-SUMMARY.md
@.planning/phases/05-signal-analysis-integration/05-02-SUMMARY.md
@src/bot/orchestrator.py
@src/bot/main.py
@src/bot/config.py
@src/bot/models.py
@src/bot/signals/models.py
@src/bot/signals/trend.py
@src/bot/signals/persistence.py
@src/bot/signals/basis.py
@src/bot/signals/volume.py
@src/bot/data/store.py
@src/bot/market_data/funding_monitor.py
@src/bot/market_data/ticker_service.py
@src/bot/market_data/opportunity_ranker.py
@tests/test_orchestrator.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Composite signal aggregator and SignalEngine</name>
  <files>
    src/bot/signals/composite.py
    src/bot/signals/engine.py
    src/bot/signals/__init__.py
    tests/test_signals/test_composite.py
    tests/test_signals/test_engine.py
  </files>
  <action>
**src/bot/signals/composite.py:**

Two public functions:

1. `normalize_rate_level(funding_rate: Decimal, cap: Decimal = Decimal("0.003")) -> Decimal`:
   - Normalize funding rate to 0-1: `min(abs(funding_rate) / cap, Decimal("1"))`
   - Cap prevents extreme rates from dominating. Rates at or above 0.3% per period get max score.
   - Use abs() so negative funding rates also produce a score (though in practice, we'd only score positive rates for our long-spot/short-perp strategy)

2. `compute_composite_score(rate_level: Decimal, trend_score: Decimal, persistence: Decimal, basis_score: Decimal, weights: dict[str, Decimal]) -> Decimal`:
   - Weighted linear combination: `weights["rate_level"] * rate_level + weights["trend"] * trend_score + weights["persistence"] * persistence + weights["basis"] * basis_score`
   - The `weights` dict has keys: "rate_level", "trend", "persistence", "basis"
   - Use `.quantize(Decimal("0.000001"))` on the result for clean output
   - All inputs expected to be in 0-1 range; output will be 0-1 if weights sum to 1.0

**Trend score mapping (used by engine, documented here):**
- RISING -> Decimal("1.0") (favorable -- rate expected to stay high or increase)
- STABLE -> Decimal("0.5") (neutral)
- FALLING -> Decimal("0.0") (unfavorable -- rate may drop)

**src/bot/signals/engine.py:**

The `SignalEngine` class orchestrates all sub-signals:

```python
class SignalEngine:
    def __init__(
        self,
        signal_settings: SignalSettings,
        data_store: HistoricalDataStore | None = None,
        ticker_service: TickerService | None = None,
        funding_monitor: FundingMonitor | None = None,
    ) -> None:
```

Key methods:

1. `async def score_opportunities(self, funding_rates: list[FundingRateData], markets: dict) -> list[CompositeOpportunityScore]`:
   - For each pair in funding_rates with rate > 0:
     a. Get historical funding rates from data_store (last `trend_ema_span * 3` periods for good EMA warmup, if data_store available)
     b. Compute trend via `classify_trend(historical_rates, span=settings.trend_ema_span, stable_threshold=settings.trend_stable_threshold)`
     c. Compute persistence via `compute_persistence_score(historical_rates, threshold=settings.persistence_threshold, max_periods=settings.persistence_max_periods)`
     d. Get spot and perp prices from ticker_service for basis spread (spot = derived spot symbol, perp = symbol)
     e. Compute basis via `compute_basis_spread(spot_price, perp_price)` and normalize via `normalize_basis_score(basis, cap=settings.basis_weight_cap)`
     f. Get OHLCV candles from data_store for volume trend (last `volume_lookback_days * 2` days)
     g. Compute volume_ok via `compute_volume_trend(candles, lookback_days=settings.volume_lookback_days, decline_ratio=settings.volume_decline_ratio)`
     h. Normalize rate level via `normalize_rate_level(rate, cap=settings.rate_normalization_cap)`
     i. Map trend to score: RISING=1.0, STABLE=0.5, FALLING=0.0
     j. Compute composite via `compute_composite_score(rate_level, trend_score, persistence, basis_score, weights)`
     k. Create `CompositeSignal` with all sub-signal values
     l. Determine `passes_entry = score >= settings.entry_threshold AND volume_ok`
     m. Derive spot symbol from markets dict (use `OpportunityRanker._derive_spot_symbol` logic -- copy it as a module-level function or import from ranker)
     n. Build `OpportunityScore` with the v1.0-compatible fields (funding_rate, net_yield, etc.) for orchestrator compatibility. For net_yield and annualized_yield, use rate as proxy (exact fee calculation not needed here -- the actual fee check happens in PositionManager)
     o. Wrap in `CompositeOpportunityScore(opportunity=opp, signal=signal)`
   - Sort by composite score descending
   - Log composite breakdown at INFO level for each scored pair (SGNL-06 requirement). Use structlog kwargs:
     ```python
     logger.info(
         "composite_signal",
         symbol=signal.symbol,
         composite_score=str(signal.score),
         rate_level=str(signal.rate_level),
         trend=signal.trend.value,
         persistence=str(signal.persistence),
         basis_spread=str(signal.basis_spread),
         volume_ok=signal.volume_ok,
         passes_entry=signal.passes_entry,
     )
     ```
   - Return list of CompositeOpportunityScore

2. `async def score_for_exit(self, symbols: list[str], funding_rates: list[FundingRateData], markets: dict) -> dict[str, CompositeSignal]`:
   - Score specific symbols (currently open positions) for exit decisions
   - Returns dict mapping symbol -> CompositeSignal
   - Same computation as score_opportunities but filtered to the given symbols
   - Used by orchestrator's composite exit logic

**Graceful degradation:**
- If data_store is None: trend = STABLE, persistence = 0, volume_ok = True
- If ticker_service is None: basis_spread = 0, basis_score = 0
- If funding_monitor is None: no index prices, but ticker_service may still have prices
- If historical data is empty for a pair: trend = STABLE, persistence = 0, volume_ok = True

**Weights dict construction** (from SignalSettings):
```python
weights = {
    "rate_level": self._settings.weight_rate_level,
    "trend": self._settings.weight_trend,
    "persistence": self._settings.weight_persistence,
    "basis": self._settings.weight_basis,
}
```

**Spot symbol derivation:**
Create a module-level helper `_derive_spot_symbol(perp_symbol: str, markets: dict) -> str | None` that replicates the logic from `OpportunityRanker._derive_spot_symbol`. Do NOT import from the ranker (keeps the signal module independent of the ranking module).

**src/bot/signals/__init__.py:**
Update to export all public symbols from all signal modules:
```python
from bot.signals.basis import compute_basis_spread, normalize_basis_score
from bot.signals.composite import compute_composite_score, normalize_rate_level
from bot.signals.engine import SignalEngine
from bot.signals.models import CompositeOpportunityScore, CompositeSignal, TrendDirection
from bot.signals.persistence import compute_persistence_score
from bot.signals.trend import classify_trend, compute_ema
from bot.signals.volume import compute_volume_trend
```

**tests/test_signals/test_composite.py:**
- Test normalize_rate_level: rate below cap, at cap, above cap
- Test compute_composite_score with equal weights (0.25 each) and known sub-scores
- Test compute_composite_score with zero weights (all zero -> score 0)
- Test compute_composite_score with single dominant weight (rate_level=1.0, rest=0)

**tests/test_signals/test_engine.py:**
- Test with all dependencies as None (full graceful degradation): should return scores with trend=STABLE, persistence=0, volume_ok=True
- Test score_opportunities returns results sorted by composite score descending
- Test score_for_exit returns dict keyed by symbol
- Use mock objects for data_store, ticker_service, funding_monitor:
  - Mock data_store.get_funding_rates to return a list of HistoricalFundingRate
  - Mock data_store.get_ohlcv_candles to return a list of OHLCVCandle
  - Mock ticker_service.get_price to return Decimal prices
- Test that passes_entry is False when volume_ok is False even if score is high
- Test that passes_entry is True when score >= entry_threshold AND volume_ok
  </action>
  <verify>
Run `python -m pytest tests/test_signals/ -v` -- all signal tests pass.
Run `python -m pytest tests/ -x -q` -- all existing tests also pass.
Run `python -c "from bot.signals import SignalEngine, compute_composite_score; print('OK')"` -- prints OK.
  </verify>
  <done>
compute_composite_score produces weighted sum from sub-signals. SignalEngine orchestrates all sub-signals, handles graceful degradation, and logs composite breakdown at INFO level. score_for_exit method supports composite exit decisions. All functions tested including graceful degradation scenarios.
  </done>
</task>

<task type="auto">
  <name>Task 2: Orchestrator integration and main.py wiring with strategy_mode feature flag</name>
  <files>
    src/bot/orchestrator.py
    src/bot/main.py
    tests/test_orchestrator.py
  </files>
  <action>
**src/bot/orchestrator.py:**

1. Add import (under `TYPE_CHECKING` guard to avoid circular imports):
   ```python
   if TYPE_CHECKING:
       from bot.data.fetcher import HistoricalDataFetcher
       from bot.data.store import HistoricalDataStore
       from bot.signals.engine import SignalEngine
   ```
   Also add a runtime import at the top for the config:
   ```python
   from bot.config import AppSettings, HistoricalDataSettings, RuntimeConfig, SignalSettings
   ```

2. Add `signal_engine` parameter to `Orchestrator.__init__()`:
   ```python
   def __init__(
       self,
       ...existing params...,
       signal_engine: SignalEngine | None = None,  # v1.1 composite signals
       signal_settings: SignalSettings | None = None,
   ) -> None:
   ```
   Store as `self._signal_engine = signal_engine` and `self._signal_settings = signal_settings`.

3. Modify `_autonomous_cycle()` to branch on strategy_mode. After step "1. SCAN" and before step "3. DECIDE & EXECUTE":

   Replace the current RANK + DECIDE + EXECUTE block:
   ```python
   # 2-3. STRATEGY: Branch on strategy mode
   if (
       self._settings.trading.strategy_mode == "composite"
       and self._signal_engine is not None
   ):
       await self._composite_strategy_cycle(all_rates, markets)
   else:
       # v1.0 path: UNCHANGED
       opportunities = self._ranker.rank_opportunities(
           funding_rates=all_rates,
           markets=markets,
           min_rate=self._settings.trading.min_funding_rate,
           min_volume_24h=self._settings.risk.min_volume_24h,
           min_holding_periods=self._settings.risk.min_holding_periods,
       )
       if opportunities:
           top = opportunities[0]
           logger.info(
               "opportunities_ranked",
               count=len(opportunities),
               top_pair=top.perp_symbol,
               top_annualized_yield=str(top.annualized_yield),
           )
       await self._close_unprofitable_positions()
       await self._open_profitable_positions(opportunities)
   ```

4. Add new method `_composite_strategy_cycle(self, all_rates, markets)`:
   ```python
   async def _composite_strategy_cycle(
       self,
       all_rates: list[FundingRateData],
       markets: dict,
   ) -> None:
       """Composite signal strategy cycle (v1.1).

       Uses SignalEngine to compute composite scores for all pairs,
       then makes entry/exit decisions based on composite thresholds.
       """
       composite_scores = await self._signal_engine.score_opportunities(
           funding_rates=all_rates,
           markets=markets,
       )

       if composite_scores:
           top = composite_scores[0]
           logger.info(
               "composite_opportunities_ranked",
               count=len(composite_scores),
               top_pair=top.opportunity.perp_symbol,
               top_composite_score=str(top.signal.score),
           )

       # EXIT: Close positions where composite score dropped below exit threshold
       await self._close_unprofitable_positions_composite(all_rates, markets)

       # ENTRY: Open positions with high composite scores
       await self._open_profitable_positions_composite(composite_scores)
   ```

5. Add `_close_unprofitable_positions_composite(self, all_rates, markets)`:
   ```python
   async def _close_unprofitable_positions_composite(
       self,
       all_rates: list[FundingRateData],
       markets: dict,
   ) -> None:
       """Close positions where composite score dropped below exit threshold (v1.1)."""
       open_positions = self._position_manager.get_open_positions()
       if not open_positions:
           return

       symbols = [p.perp_symbol for p in open_positions]
       exit_scores = await self._signal_engine.score_for_exit(
           symbols=symbols,
           funding_rates=all_rates,
           markets=markets,
       )

       exit_threshold = (
           self._signal_settings.exit_threshold
           if self._signal_settings
           else Decimal("0.3")
       )

       for position in open_positions:
           signal = exit_scores.get(position.perp_symbol)
           # Close if: no signal data available OR score below exit threshold
           if signal is None or signal.score < exit_threshold:
               reason = (
                   "signal_unavailable"
                   if signal is None
                   else f"composite_below_exit_{signal.score}"
               )
               logger.info(
                   "closing_position_composite",
                   position_id=position.id,
                   perp_symbol=position.perp_symbol,
                   reason=reason,
               )
               try:
                   await self.close_position(position.id)
               except Exception as e:
                   logger.error(
                       "close_composite_failed",
                       position_id=position.id,
                       error=str(e),
                   )
   ```

6. Add `_open_profitable_positions_composite(self, composite_scores)`:
   ```python
   async def _open_profitable_positions_composite(
       self,
       composite_scores: list,  # list[CompositeOpportunityScore]
   ) -> None:
       """Open positions on top composite-scored pairs within risk limits (v1.1)."""
       for cs in composite_scores:
           if not cs.signal.passes_entry:
               continue

           opp = cs.opportunity
           can_open, reason = self._risk_manager.check_can_open(
               symbol=opp.perp_symbol,
               position_size_usd=self._settings.trading.max_position_size_usd,
               current_positions=self._position_manager.get_open_positions(),
           )
           if not can_open:
               logger.debug(
                   "risk_check_rejected_composite",
                   symbol=opp.perp_symbol,
                   reason=reason,
               )
               continue

           try:
               await self.open_position(opp.spot_symbol, opp.perp_symbol)
               logger.info(
                   "composite_position_opened",
                   spot_symbol=opp.spot_symbol,
                   perp_symbol=opp.perp_symbol,
                   composite_score=str(cs.signal.score),
               )
           except Exception as e:
               logger.error(
                   "composite_open_failed",
                   symbol=opp.perp_symbol,
                   error=str(e),
               )
   ```

**src/bot/main.py:**

1. Add import:
   ```python
   from bot.signals.engine import SignalEngine
   ```

2. In `_build_components()`, after creating the orchestrator's existing dependencies and before creating the orchestrator, add SignalEngine creation (after historical data components, around line 147):
   ```python
   # 14.6. Create signal engine (optional v1.1 composite signals)
   signal_engine = None
   if settings.trading.strategy_mode == "composite":
       signal_engine = SignalEngine(
           signal_settings=settings.signal,
           data_store=data_store,
           ticker_service=ticker_service,
           funding_monitor=funding_monitor,
       )
   ```

3. Add `signal_engine` and `signal_settings` to the Orchestrator constructor call:
   ```python
   orchestrator = Orchestrator(
       ...existing args...,
       signal_engine=signal_engine,
       signal_settings=settings.signal if signal_engine else None,
   )
   ```

4. Add `signal_engine` to the returned components dict:
   ```python
   "signal_engine": signal_engine,
   ```

**tests/test_orchestrator.py:**

Add 2-3 targeted tests for the composite path without breaking existing tests:

1. Test that existing orchestrator tests still pass unchanged (they use default strategy_mode="simple", so the v1.0 path runs). **Do not modify any existing test.**

2. Add a new test: `test_composite_mode_uses_signal_engine`:
   - Create a mock SignalEngine with `score_opportunities` returning a list of CompositeOpportunityScore
   - Create a mock `score_for_exit` returning an empty dict (no open positions to exit)
   - Set `settings.trading.strategy_mode = "composite"`
   - Verify that `_signal_engine.score_opportunities` is called (not `_ranker.rank_opportunities`)

3. Add a new test: `test_simple_mode_uses_ranker`:
   - Set `settings.trading.strategy_mode = "simple"` (or leave as default)
   - Verify that `_ranker.rank_opportunities` is called (not `_signal_engine.score_opportunities`)

Use the existing test fixtures and patterns from `tests/test_orchestrator.py`. Follow the mocking patterns already established there.
  </action>
  <verify>
Run `python -m pytest tests/test_orchestrator.py -v` -- all tests pass (existing + new).
Run `python -m pytest tests/ -x -q` -- full suite passes.
Run `python -c "from bot.orchestrator import Orchestrator; from bot.main import _build_components; print('OK')"` -- imports clean.
Verify strategy_mode simple path: `python -c "from bot.config import AppSettings; s = AppSettings(); assert s.trading.strategy_mode == 'simple'; print('v1.0 default preserved')"` -- prints confirmation.
  </verify>
  <done>
Composite signal replaces simple threshold for entry AND exit when strategy_mode="composite". Simple mode (v1.0) path is completely unchanged and remains the default. SignalEngine wired into component graph with optional injection. Composite scores logged at INFO level per SGNL-06. All existing tests pass unchanged. New tests verify the strategy mode branching.
  </done>
</task>

</tasks>

<verification>
1. `python -m pytest tests/ -x -q` -- full test suite passes
2. `python -c "from bot.config import AppSettings; s = AppSettings(); assert s.trading.strategy_mode == 'simple'; print('PASS: v1.0 default')"` -- v1.0 preserved
3. `grep -n "strategy_mode" src/bot/orchestrator.py` -- confirms branching exists
4. `grep -n "composite_signal" src/bot/signals/engine.py` -- confirms INFO logging
5. `grep -n "signal_engine" src/bot/main.py` -- confirms wiring
6. `grep -n "SignalEngine" src/bot/orchestrator.py` -- confirms integration
7. Verify all 6 SGNL requirements covered:
   - SGNL-01: trend.py classify_trend (Plan 01)
   - SGNL-02: persistence.py compute_persistence_score (Plan 01)
   - SGNL-03: composite.py compute_composite_score (this plan)
   - SGNL-04: basis.py compute_basis_spread (Plan 02)
   - SGNL-05: volume.py compute_volume_trend (Plan 02)
   - SGNL-06: engine.py + orchestrator integration (this plan)
</verification>

<success_criteria>
- compute_composite_score produces weighted sum from sub-signals
- SignalEngine.score_opportunities computes all sub-signals and returns ranked composite scores
- SignalEngine.score_for_exit scores specific symbols for exit decisions
- Orchestrator branches on strategy_mode for both entry AND exit
- strategy_mode="simple" runs v1.0 path identically (all existing tests pass)
- strategy_mode="composite" runs composite signal path
- SignalEngine injected into Orchestrator as | None = None
- main.py creates SignalEngine only when strategy_mode="composite"
- Composite breakdown logged at INFO level (SGNL-06)
- All 6 SGNL requirements satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/05-signal-analysis-integration/05-03-SUMMARY.md`
</output>
