---
phase: 02-multi-pair-intelligence
plan: 02
type: tdd
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/bot/market_data/opportunity_ranker.py
  - tests/test_market_data/test_opportunity_ranker.py
autonomous: true

must_haves:
  truths:
    - "Pairs with funding rate below min_rate are excluded from rankings"
    - "Pairs with volume below min_volume_24h are excluded from rankings"
    - "Pairs without a matching active spot symbol are excluded"
    - "Net yield correctly subtracts amortized round-trip fees from funding rate"
    - "Annualized yield accounts for funding interval differences (4h vs 8h)"
    - "Results are sorted by annualized yield descending"
    - "Pairs with negative net yield have passes_filters=False"
  artifacts:
    - path: "src/bot/market_data/opportunity_ranker.py"
      provides: "OpportunityRanker with rank_opportunities method"
      exports: ["OpportunityRanker"]
      min_lines: 50
    - path: "tests/test_market_data/test_opportunity_ranker.py"
      provides: "Comprehensive test suite for ranking logic"
      min_lines: 80
  key_links:
    - from: "src/bot/market_data/opportunity_ranker.py"
      to: "src/bot/models.py"
      via: "Uses FundingRateData as input, returns OpportunityScore list"
      pattern: "FundingRateData|OpportunityScore"
    - from: "src/bot/market_data/opportunity_ranker.py"
      to: "src/bot/pnl/fee_calculator.py"
      via: "Uses FeeCalculator for round-trip fee percentage"
      pattern: "FeeCalculator|round_trip"
---

<objective>
Build the OpportunityRanker using TDD -- a pure computation module that scores and ranks funding rate pairs by net yield after fees, filtering by volume, minimum rate, and spot pair availability.

Purpose: The ranker is the decision engine for which pairs to trade. Net yield (not raw funding rate) determines profitability. Correct fee amortization and interval normalization are critical for accurate ranking. TDD ensures the math is right.
Output: Tested OpportunityRanker class with rank_opportunities method.
</objective>

<execution_context>
@/Users/luckleineschaars/.claude/get-shit-done/workflows/execute-plan.md
@/Users/luckleineschaars/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-multi-pair-intelligence/02-RESEARCH.md
@src/bot/models.py
@src/bot/pnl/fee_calculator.py
@src/bot/config.py
</context>

<feature>
  <name>OpportunityRanker: Net Yield Scoring and Ranking</name>
  <files>src/bot/market_data/opportunity_ranker.py, tests/test_market_data/test_opportunity_ranker.py</files>
  <behavior>
  The OpportunityRanker takes a list of FundingRateData and produces a ranked list of OpportunityScore objects.

  **Core formula:**
  - `round_trip_fee_pct = (spot_taker + perp_taker) * 2` (entry + exit, both legs taker)
  - `amortized_fee = round_trip_fee_pct / min_holding_periods`
  - `net_yield_per_period = funding_rate - amortized_fee`
  - `periods_per_year = 8760 / interval_hours` (8760 = 365 * 24)
  - `annualized_yield = net_yield_per_period * periods_per_year`
  - `passes_filters = net_yield_per_period > 0`

  **Spot symbol derivation:**
  - Uses ccxt markets dict to find matching spot pair
  - perp "BTC/USDT:USDT" -> spot "BTC/USDT" (must be active spot market)
  - If no matching spot -> excluded

  **Test cases (input -> expected):**
  1. Single pair above threshold with spot available -> 1 result, correct net yield
  2. Pair below min_rate -> excluded (0 results)
  3. Pair below min_volume -> excluded (0 results)
  4. Pair with no matching spot symbol -> excluded
  5. Two pairs with different interval_hours (4h vs 8h) at same raw rate -> different annualized yields, 4h pair ranked higher
  6. Pair where fee exceeds funding rate -> passes_filters=False
  7. Multiple pairs -> sorted by annualized_yield descending
  8. Empty input -> empty output
  </behavior>
  <implementation>
  Create `OpportunityRanker` class in `src/bot/market_data/opportunity_ranker.py`:

  ```python
  class OpportunityRanker:
      def __init__(self, fee_settings: FeeSettings) -> None:
          self._fee_settings = fee_settings

      def rank_opportunities(
          self,
          funding_rates: list[FundingRateData],
          markets: dict,
          min_rate: Decimal,
          min_volume_24h: Decimal = Decimal("1000000"),
          min_holding_periods: int = 3,
      ) -> list[OpportunityScore]:
  ```

  The method:
  1. Computes round_trip_fee_pct from fee_settings (spot_taker + perp_taker) * 2
  2. For each FundingRateData:
     a. Skip if rate < min_rate
     b. Skip if volume_24h < min_volume_24h
     c. Derive spot symbol via markets dict lookup (call _derive_spot_symbol)
     d. Skip if no valid spot symbol
     e. Compute net_yield_per_period and annualized_yield
     f. Create OpportunityScore
  3. Sort by annualized_yield descending
  4. Return list

  Static method `_derive_spot_symbol(perp_symbol, markets) -> str | None`:
  - Look up perp in markets to get base/quote
  - Construct spot symbol as "BASE/QUOTE"
  - Verify spot symbol exists in markets with spot=True and active=True
  - Return spot symbol or None
  </implementation>
</feature>

<verification>
`cd /Users/luckleineschaars/repos/funding-rate-arbitrage && .venv/bin/python -m pytest tests/test_market_data/test_opportunity_ranker.py -v` -- all tests pass
`cd /Users/luckleineschaars/repos/funding-rate-arbitrage && .venv/bin/python -m pytest tests/ -x -q` -- full suite passes
`cd /Users/luckleineschaars/repos/funding-rate-arbitrage && .venv/bin/ruff check src/bot/market_data/opportunity_ranker.py` -- no lint errors
</verification>

<success_criteria>
- RED: All 8+ test cases written and failing (OpportunityRanker not yet implemented)
- GREEN: Minimal OpportunityRanker implementation passes all tests
- REFACTOR: Clean code, no duplication
- Net yield formula correctly subtracts amortized fees
- Annualized yield correctly uses interval_hours (not hardcoded 8)
- Spot symbol derivation uses markets dict (not string manipulation)
- Empty/edge cases handled gracefully
</success_criteria>

<output>
After completion, create `.planning/phases/02-multi-pair-intelligence/02-02-SUMMARY.md`
</output>
