---
phase: 02-multi-pair-intelligence
plan: 04
type: execute
wave: 3
depends_on: ["02-02", "02-03"]
files_modified:
  - src/bot/orchestrator.py
  - src/bot/main.py
  - tests/test_orchestrator.py
autonomous: true

must_haves:
  truths:
    - "Orchestrator runs autonomous scan-rank-decide-execute cycle each iteration"
    - "Bot opens positions on top-ranked pairs that pass risk checks"
    - "Bot closes positions when funding rate drops below exit_funding_rate"
    - "Bot skips pairs that already have open positions"
    - "Bot checks margin ratio each cycle and logs alert when threshold exceeded"
    - "Emergency stop triggers when margin reaches critical threshold"
    - "SIGUSR1 signal triggers EmergencyController"
    - "SIGINT/SIGTERM trigger graceful shutdown with position close"
    - "Only one autonomous cycle runs at a time (no overlapping cycles)"
  artifacts:
    - path: "src/bot/orchestrator.py"
      provides: "Autonomous scan-rank-decide-execute orchestrator loop"
      exports: ["Orchestrator"]
      min_lines: 150
    - path: "src/bot/main.py"
      provides: "Full component wiring including Phase 2 components and signal handlers"
      exports: ["run", "main"]
      min_lines: 80
    - path: "tests/test_orchestrator.py"
      provides: "Integration tests for autonomous cycle"
      min_lines: 80
  key_links:
    - from: "src/bot/orchestrator.py"
      to: "src/bot/market_data/opportunity_ranker.py"
      via: "Calls rank_opportunities in each cycle"
      pattern: "rank_opportunities"
    - from: "src/bot/orchestrator.py"
      to: "src/bot/risk/manager.py"
      via: "Calls check_can_open before each position open, check_margin_ratio each cycle"
      pattern: "check_can_open|check_margin_ratio"
    - from: "src/bot/orchestrator.py"
      to: "src/bot/risk/emergency.py"
      via: "Triggers emergency on margin critical or references EmergencyController"
      pattern: "emergency|trigger"
    - from: "src/bot/main.py"
      to: "src/bot/risk/emergency.py"
      via: "Wires EmergencyController and registers SIGUSR1 handler"
      pattern: "EmergencyController|SIGUSR1"
---

<objective>
Rewrite Orchestrator._run_loop() from passive monitor to autonomous scan-rank-decide-execute cycle. Wire all Phase 2 components in main.py with signal-based emergency stop.

Purpose: This plan integrates all Phase 2 components into a working autonomous trading bot. The orchestrator becomes the decision maker: scanning markets, ranking opportunities, opening profitable positions, closing unprofitable ones, and enforcing risk limits every cycle.
Output: Autonomous bot loop, complete main.py wiring, integration tests.
</objective>

<execution_context>
@/Users/luckleineschaars/.claude/get-shit-done/workflows/execute-plan.md
@/Users/luckleineschaars/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-multi-pair-intelligence/02-RESEARCH.md
@.planning/phases/02-multi-pair-intelligence/02-01-SUMMARY.md
@.planning/phases/02-multi-pair-intelligence/02-02-SUMMARY.md
@.planning/phases/02-multi-pair-intelligence/02-03-SUMMARY.md
@src/bot/orchestrator.py
@src/bot/main.py
@src/bot/config.py
@src/bot/models.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Rewrite Orchestrator with autonomous scan-rank-decide-execute cycle</name>
  <files>src/bot/orchestrator.py, tests/test_orchestrator.py</files>
  <action>
Rewrite `src/bot/orchestrator.py` to add autonomous trading. Keep all existing functionality (funding settlement, open/close convenience methods, get_status) but replace the passive `_run_loop` with an active decision cycle.

**Constructor changes:**
Add new dependencies to `__init__`:
- `risk_manager: RiskManager` (from bot.risk.manager)
- `ranker: OpportunityRanker` (from bot.market_data.opportunity_ranker)
- `emergency_controller: EmergencyController` (from bot.risk.emergency)

Store all three as instance variables. Add `_cycle_lock = asyncio.Lock()` to prevent overlapping cycles.

**Replace `_run_loop()` body:**
Keep the while loop structure but call `_autonomous_cycle()` instead of passive monitoring:

```python
async def _run_loop(self) -> None:
    while self._running:
        try:
            async with self._cycle_lock:
                await self._autonomous_cycle()
            self._check_funding_settlement()
            await asyncio.sleep(self._settings.trading.scan_interval)
        except asyncio.CancelledError:
            break
        except Exception as e:
            logger.error("orchestrator_cycle_error", error=str(e), exc_info=True)
            await asyncio.sleep(10)
```

**New method `_autonomous_cycle()`:**
Implements the scan-rank-decide-execute pattern from research:

```python
async def _autonomous_cycle(self) -> None:
    """One iteration of the autonomous trading loop."""
    # 1. SCAN: Get all funding rates from monitor cache
    all_rates = self._funding_monitor.get_all_funding_rates()
    if not all_rates:
        logger.debug("no_funding_rates_available")
        return

    # 2. RANK: Score each pair by net yield after fees
    markets = self._exchange_client.get_markets()
    opportunities = self._ranker.rank_opportunities(
        funding_rates=all_rates,
        markets=markets,
        min_rate=self._settings.trading.min_funding_rate,
        min_volume_24h=self._settings.risk.min_volume_24h,
        min_holding_periods=self._settings.risk.min_holding_periods,
    )

    if opportunities:
        top = opportunities[0]
        logger.info(
            "opportunities_ranked",
            count=len(opportunities),
            top_pair=top.perp_symbol,
            top_annualized_yield=str(top.annualized_yield),
        )

    # 3. DECIDE & EXECUTE: Close unprofitable, open profitable
    await self._close_unprofitable_positions()
    await self._open_profitable_positions(opportunities)

    # 4. MONITOR: Check margin ratio
    await self._check_margin_ratio()

    # 5. LOG: Position status
    self._log_position_status()
```

**New method `_close_unprofitable_positions()`:**
```python
async def _close_unprofitable_positions(self) -> None:
    """Close positions where funding rate dropped below exit threshold (EXEC-02)."""
    for position in self._position_manager.get_open_positions():
        rate_data = self._funding_monitor.get_funding_rate(position.perp_symbol)
        if rate_data is None or rate_data.rate < self._settings.risk.exit_funding_rate:
            reason = "rate_unavailable" if rate_data is None else f"rate_below_exit_{rate_data.rate}"
            logger.info(
                "closing_unprofitable_position",
                position_id=position.id,
                perp_symbol=position.perp_symbol,
                reason=reason,
            )
            try:
                await self.close_position(position.id)
            except Exception as e:
                logger.error("close_unprofitable_failed", position_id=position.id, error=str(e))
```

**New method `_open_profitable_positions(opportunities)`:**
```python
async def _open_profitable_positions(self, opportunities: list[OpportunityScore]) -> None:
    """Open positions on top-ranked pairs within risk limits (MKTD-02, MKTD-03)."""
    for opp in opportunities:
        if not opp.passes_filters:
            continue

        # Check risk limits
        can_open, reason = self._risk_manager.check_can_open(
            symbol=opp.perp_symbol,
            position_size_usd=self._settings.trading.max_position_size_usd,
            current_positions=self._position_manager.get_open_positions(),
        )
        if not can_open:
            logger.debug("risk_check_rejected", symbol=opp.perp_symbol, reason=reason)
            continue

        # Open position
        try:
            await self.open_position(opp.spot_symbol, opp.perp_symbol)
            logger.info(
                "autonomous_position_opened",
                spot_symbol=opp.spot_symbol,
                perp_symbol=opp.perp_symbol,
                annualized_yield=str(opp.annualized_yield),
            )
        except Exception as e:
            logger.error(
                "autonomous_open_failed",
                symbol=opp.perp_symbol,
                error=str(e),
            )
```

**New method `_check_margin_ratio()`:**
```python
async def _check_margin_ratio(self) -> None:
    """RISK-05: Check margin ratio and trigger alerts or emergency stop."""
    try:
        mm_rate, is_alert = await self._risk_manager.check_margin_ratio()
        if self._risk_manager.is_margin_critical(mm_rate):
            logger.critical("margin_critical_triggering_emergency", mm_rate=str(mm_rate))
            await self._emergency_controller.trigger(f"margin_critical_{mm_rate}")
            return
        if is_alert:
            logger.warning("margin_alert", mm_rate=str(mm_rate),
                          threshold=str(self._settings.risk.margin_alert_threshold))
    except Exception as e:
        logger.error("margin_check_failed", error=str(e))
```

**New method `_log_position_status()`:**
```python
def _log_position_status(self) -> None:
    """Log P&L status for all open positions."""
    for position in self._position_manager.get_open_positions():
        pnl = self._pnl_tracker.get_total_pnl(position.id)
        logger.info(
            "position_status",
            position_id=position.id,
            symbol=position.perp_symbol,
            net_pnl=str(pnl["net_pnl"]),
            funding_collected=str(pnl["total_funding"]),
        )
```

**Update `get_status()`:** Add risk info: margin_ratio, open positions details, emergency_triggered.

**Update `stop()`:** In graceful shutdown, close all open positions before stopping:
```python
async def stop(self) -> None:
    logger.info("orchestrator_stopping_gracefully")
    self._running = False
    # Close all positions gracefully on shutdown
    for position in self._position_manager.get_open_positions():
        try:
            await self.close_position(position.id)
        except Exception as e:
            logger.error("graceful_close_failed", position_id=position.id, error=str(e))
```

**Tests** in `tests/test_orchestrator.py`:
Update existing tests to pass the new constructor args (risk_manager, ranker, emergency_controller as mocks).

Add new tests:
- Test autonomous cycle opens position when opportunity passes risk check
- Test autonomous cycle closes position when rate drops below exit threshold
- Test autonomous cycle skips pairs rejected by risk manager
- Test margin critical triggers emergency controller
- Test graceful stop closes all open positions
- Test cycle lock prevents overlapping cycles

Use AsyncMock extensively. Create mock OpportunityRanker returning pre-built OpportunityScore objects. Mock RiskManager.check_can_open to return (True, "") or (False, "reason").
  </action>
  <verify>
  Run `cd /Users/luckleineschaars/repos/funding-rate-arbitrage && .venv/bin/python -m pytest tests/test_orchestrator.py -v` -- all tests pass
  Run `cd /Users/luckleineschaars/repos/funding-rate-arbitrage && .venv/bin/python -m pytest tests/ -x -q` -- full suite passes
  Run `cd /Users/luckleineschaars/repos/funding-rate-arbitrage && .venv/bin/ruff check src/bot/orchestrator.py` -- no lint errors
  </verify>
  <done>Orchestrator runs autonomous scan-rank-decide-execute cycle. Opens top-ranked positions within risk limits. Closes positions when funding rate drops below exit threshold. Monitors margin ratio and triggers emergency on critical. Cycle lock prevents overlapping iterations. All tests pass.</done>
</task>

<task type="auto">
  <name>Task 2: Wire Phase 2 components in main.py with signal-based emergency stop</name>
  <files>src/bot/main.py</files>
  <action>
Update `src/bot/main.py` to wire all Phase 2 components:

**New imports:**
```python
from bot.config import RiskSettings
from bot.market_data.opportunity_ranker import OpportunityRanker
from bot.risk.manager import RiskManager
from bot.risk.emergency import EmergencyController
```

**New wiring steps (insert between existing steps 11 and 12):**

After PnLTracker (step 11), add:
```python
# 12. Create opportunity ranker
ranker = OpportunityRanker(settings.fees)

# 13. Create risk manager
# In paper mode, provide paper margin simulation; in live mode, use exchange client
risk_manager = RiskManager(
    settings=settings.risk,
    exchange_client=exchange_client if settings.trading.mode == "live" else None,
)
```

**Update orchestrator creation (now step 14):**
```python
orchestrator = Orchestrator(
    settings=settings,
    exchange_client=exchange_client,
    funding_monitor=funding_monitor,
    ticker_service=ticker_service,
    position_manager=position_manager,
    pnl_tracker=pnl_tracker,
    delta_validator=delta_validator,
    fee_calculator=fee_calculator,
    risk_manager=risk_manager,
    ranker=ranker,
    emergency_controller=None,  # Set after orchestrator created (circular ref)
)

# 15. Create emergency controller (needs orchestrator.stop as callback)
emergency_controller = EmergencyController(
    position_manager=position_manager,
    pnl_tracker=pnl_tracker,
    stop_callback=orchestrator.stop,
)
orchestrator._emergency_controller = emergency_controller
```

Note: The circular dependency (emergency needs orchestrator.stop, orchestrator needs emergency) is resolved by creating emergency after orchestrator and injecting it. Use a setter or direct assignment -- add a `set_emergency_controller` method to Orchestrator if you prefer clean API over direct attribute access.

**Update signal handling (now step 16):**
```python
loop = asyncio.get_running_loop()

def _graceful_handler() -> None:
    logger.info("graceful_shutdown_signal")
    asyncio.create_task(orchestrator.stop())

def _emergency_handler() -> None:
    logger.critical("emergency_stop_signal_received")
    asyncio.create_task(emergency_controller.trigger("user_signal_SIGUSR1"))

# SIGINT/SIGTERM = graceful (stop bot, close positions cleanly)
for sig in (signal.SIGINT, signal.SIGTERM):
    loop.add_signal_handler(sig, _graceful_handler)

# SIGUSR1 = emergency stop (close all immediately)
loop.add_signal_handler(signal.SIGUSR1, _emergency_handler)
```

**Update step numbering in the docstring** to reflect new component order.

**Log startup info:**
```python
logger.info(
    "funding_rate_arbitrage_starting",
    mode=settings.trading.mode,
    max_positions=settings.risk.max_simultaneous_positions,
    max_position_size=str(settings.risk.max_position_size_per_pair),
    exit_rate=str(settings.risk.exit_funding_rate),
)
```
  </action>
  <verify>
  Run `cd /Users/luckleineschaars/repos/funding-rate-arbitrage && .venv/bin/python -c "from bot.main import run; print('import OK')"` -- imports succeed
  Run `cd /Users/luckleineschaars/repos/funding-rate-arbitrage && .venv/bin/python -m pytest tests/ -x -q` -- full suite passes
  Run `cd /Users/luckleineschaars/repos/funding-rate-arbitrage && .venv/bin/ruff check src/bot/main.py` -- no lint errors
  </verify>
  <done>main.py wires all Phase 2 components: OpportunityRanker, RiskManager, EmergencyController. SIGUSR1 triggers emergency stop. SIGINT/SIGTERM trigger graceful shutdown with position close. Startup log shows risk configuration. All tests pass.</done>
</task>

</tasks>

<verification>
1. `cd /Users/luckleineschaars/repos/funding-rate-arbitrage && .venv/bin/python -m pytest tests/ -x -q` -- all tests pass
2. `cd /Users/luckleineschaars/repos/funding-rate-arbitrage && .venv/bin/ruff check src/bot/` -- no lint errors across entire bot
3. `cd /Users/luckleineschaars/repos/funding-rate-arbitrage && .venv/bin/python -c "from bot.main import run; from bot.orchestrator import Orchestrator; print('all imports OK')"` -- all Phase 2 modules importable
4. Verify autonomous cycle flow: ranker -> risk check -> open/close -> margin check (via test output)
</verification>

<success_criteria>
- Orchestrator runs scan-rank-decide-execute cycle autonomously each iteration
- Positions opened on highest-yield pairs that pass all risk checks
- Positions closed when funding rate drops below exit_funding_rate (EXEC-02)
- Risk checks prevent exceeding per-pair or total position limits (RISK-01, RISK-02)
- Margin ratio checked each cycle with alerts (RISK-05)
- Critical margin triggers emergency stop
- SIGUSR1 triggers emergency stop (RISK-03)
- SIGINT/SIGTERM trigger graceful shutdown with position close
- Cycle lock prevents overlapping autonomous cycles
- All Phase 1 and Phase 2 tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/02-multi-pair-intelligence/02-04-SUMMARY.md`
</output>
