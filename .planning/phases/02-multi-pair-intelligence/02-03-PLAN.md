---
phase: 02-multi-pair-intelligence
plan: 03
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/bot/risk/manager.py
  - src/bot/risk/emergency.py
  - tests/test_risk/__init__.py
  - tests/test_risk/test_manager.py
  - tests/test_risk/test_emergency.py
autonomous: true

must_haves:
  truths:
    - "RiskManager rejects positions exceeding max_position_size_per_pair"
    - "RiskManager rejects when at max_simultaneous_positions"
    - "RiskManager rejects duplicate positions on same perp symbol"
    - "RiskManager.check_margin_ratio returns margin ratio and alert flag from exchange data"
    - "EmergencyController closes all open positions concurrently using asyncio.gather"
    - "EmergencyController retries failed closes up to 3 times with exponential backoff"
    - "EmergencyController logs CRITICAL for positions that remain open after all retries"
    - "EmergencyController invokes stop callback after closing positions"
  artifacts:
    - path: "src/bot/risk/manager.py"
      provides: "Expanded RiskManager with per-pair, max-positions, margin checks"
      exports: ["RiskManager"]
      min_lines: 60
    - path: "src/bot/risk/emergency.py"
      provides: "EmergencyController with concurrent close-all and retry"
      exports: ["EmergencyController"]
      min_lines: 60
    - path: "tests/test_risk/test_manager.py"
      provides: "Tests for all risk check scenarios"
      min_lines: 60
    - path: "tests/test_risk/test_emergency.py"
      provides: "Tests for emergency close including partial failure"
      min_lines: 50
  key_links:
    - from: "src/bot/risk/manager.py"
      to: "src/bot/config.py"
      via: "Uses RiskSettings for all thresholds"
      pattern: "RiskSettings"
    - from: "src/bot/risk/manager.py"
      to: "src/bot/exchange/client.py"
      via: "Calls fetch_wallet_balance_raw for margin monitoring"
      pattern: "fetch_wallet_balance_raw"
    - from: "src/bot/risk/emergency.py"
      to: "src/bot/orchestrator.py"
      via: "Calls orchestrator stop callback and position_manager close"
      pattern: "stop_callback|close_position"
---

<objective>
Expand RiskManager from Phase 1 stub into comprehensive pre-trade and runtime risk engine. Build EmergencyController for atomic close-all with retry logic.

Purpose: RISK-01 through RISK-05 and RISK-03 (emergency stop) are the safety guardrails that prevent the bot from exceeding exposure limits or leaving unmanaged positions during emergencies.
Output: Fully tested RiskManager and EmergencyController.
</objective>

<execution_context>
@/Users/luckleineschaars/.claude/get-shit-done/workflows/execute-plan.md
@/Users/luckleineschaars/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-multi-pair-intelligence/02-RESEARCH.md
@src/bot/risk/manager.py
@src/bot/config.py
@src/bot/models.py
@src/bot/exceptions.py
@src/bot/exchange/client.py
@src/bot/position/manager.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Expand RiskManager with per-pair limits, max positions, and margin monitoring</name>
  <files>src/bot/risk/manager.py, tests/test_risk/__init__.py, tests/test_risk/test_manager.py</files>
  <action>
Rewrite `src/bot/risk/manager.py` to use `RiskSettings` instead of `TradingSettings`:

```python
class RiskManager:
    def __init__(self, settings: RiskSettings, exchange_client: ExchangeClient | None = None) -> None:
```

The `exchange_client` is optional because paper mode uses `simulate_paper_margin` instead. Accept an optional `paper_margin_fn` callable too for paper mode.

**Methods to implement:**

1. `check_can_open(self, symbol: str, position_size_usd: Decimal, current_positions: list[Position]) -> tuple[bool, str]`:
   - RISK-01: Reject if `position_size_usd > settings.max_position_size_per_pair`. Return `(False, "Exceeds max per-pair size: {max}")`
   - RISK-02: Reject if `len(current_positions) >= settings.max_simultaneous_positions`. Return `(False, "At max positions: {max}")`
   - Reject if `position_size_usd <= 0`. Return `(False, "Position size must be positive")`
   - Reject duplicate: if `symbol in {p.perp_symbol for p in current_positions}`. Return `(False, "Already have position in {symbol}")`
   - Return `(True, "")` if all checks pass

2. `async check_margin_ratio(self) -> tuple[Decimal, bool]` (RISK-05):
   - If exchange_client is available: call `fetch_wallet_balance_raw()`, extract `accountMMRate` from dict
   - If paper mode (no exchange_client): return simulated values
   - Return `(mm_rate, is_alert)` where `is_alert = mm_rate >= settings.margin_alert_threshold`
   - Log warning if is_alert is True with structlog

3. `is_margin_critical(self, mm_rate: Decimal) -> bool`:
   - Return `mm_rate >= settings.margin_critical_threshold`
   - Used by orchestrator to trigger emergency stop

**IMPORTANT:** The Phase 1 RiskManager was imported in `src/bot/position/manager.py` -- check if PositionManager uses it. Looking at the code, PositionManager does NOT directly use RiskManager (the orchestrator calls risk checks before calling position_manager). So changing the RiskManager signature is safe. However, verify by checking all imports of `from bot.risk.manager import RiskManager`.

**Tests** in `tests/test_risk/test_manager.py`:
- Test check_can_open allows valid position (no limits hit)
- Test rejects exceeding max_position_size_per_pair
- Test rejects at max_simultaneous_positions
- Test rejects duplicate symbol
- Test rejects zero/negative size
- Test check_margin_ratio returns ratio and alert flag (mock exchange_client)
- Test is_margin_critical returns True above threshold
- Create `tests/test_risk/__init__.py` (empty)
  </action>
  <verify>
  Run `cd /Users/luckleineschaars/repos/funding-rate-arbitrage && .venv/bin/python -m pytest tests/test_risk/test_manager.py -v` -- all tests pass
  Run `cd /Users/luckleineschaars/repos/funding-rate-arbitrage && .venv/bin/python -m pytest tests/ -x -q` -- full suite passes (check no regressions from RiskManager signature change)
  </verify>
  <done>RiskManager enforces RISK-01 (per-pair size), RISK-02 (max positions), RISK-05 (margin monitoring), and duplicate pair prevention. All checks return clear (allowed, reason) tuples. Tests cover all branches.</done>
</task>

<task type="auto">
  <name>Task 2: Build EmergencyController with concurrent close-all and retry</name>
  <files>src/bot/risk/emergency.py, tests/test_risk/test_emergency.py</files>
  <action>
Create `src/bot/risk/emergency.py`:

```python
class EmergencyController:
    """Emergency stop: close all positions immediately with retry logic.

    RISK-03: User-triggered emergency stop that closes all open positions.
    Uses asyncio.gather for concurrent close with 3 retries per position
    and exponential backoff.
    """

    def __init__(
        self,
        position_manager: PositionManager,
        pnl_tracker: PnLTracker,
        stop_callback: Callable[[], Awaitable[None]],
        max_retries: int = 3,
    ) -> None:
```

**Fields:**
- `_position_manager`: For closing positions
- `_pnl_tracker`: For recording P&L on close
- `_stop_callback`: Async callable to stop orchestrator
- `_max_retries`: Maximum retry attempts per position (default 3)
- `_triggered: bool = False` (prevents re-entry)

**Methods:**

1. `async trigger(self, reason: str) -> tuple[list[str], list[str]]`:
   - If `_triggered`, log warning and return early with ([], [])
   - Set `_triggered = True`
   - Log CRITICAL: `"emergency_stop_triggered", reason=reason`
   - Get all open positions from position_manager
   - If no positions, call stop_callback and return ([], [])
   - Create one `_close_with_retry(position)` task per position
   - Run all with `asyncio.gather(*tasks, return_exceptions=True)`
   - Collect results into `closed_ids` and `failed_ids` lists
   - For failed positions, log CRITICAL with position details (symbol, quantity) so user can manually close
   - Call `_stop_callback()` to halt orchestrator
   - Return `(closed_ids, failed_ids)`

2. `async _close_with_retry(self, position: Position) -> str`:
   - For attempt in range(max_retries):
     - Try: `position_manager.close_position(position.id)`
     - Record P&L via pnl_tracker.record_close (use filled prices from close results)
     - Return position.id on success
   - On failure: `await asyncio.sleep(1 * (attempt + 1))` (linear backoff)
   - After all retries exhausted, raise the last exception

3. `@property triggered(self) -> bool`: Return _triggered flag

4. `def reset(self) -> None`: Set _triggered = False (for testing / recovery)

**Tests** in `tests/test_risk/test_emergency.py`:
- Test trigger closes all positions successfully (mock position_manager.close_position returns results)
- Test trigger with one position failing all retries (returns in failed_ids list)
- Test trigger calls stop_callback
- Test trigger on empty positions (no errors, calls stop_callback)
- Test double trigger returns early
- Test retry backoff (use AsyncMock side_effect to fail first then succeed)

Use `unittest.mock.AsyncMock` for async mocks. Create `Callable[[], Awaitable[None]]` stop callback as `AsyncMock()`.
  </action>
  <verify>
  Run `cd /Users/luckleineschaars/repos/funding-rate-arbitrage && .venv/bin/python -m pytest tests/test_risk/test_emergency.py -v` -- all tests pass
  Run `cd /Users/luckleineschaars/repos/funding-rate-arbitrage && .venv/bin/python -m pytest tests/ -x -q` -- full suite passes
  Run `cd /Users/luckleineschaars/repos/funding-rate-arbitrage && .venv/bin/ruff check src/bot/risk/emergency.py` -- no lint errors
  </verify>
  <done>EmergencyController closes all positions concurrently via asyncio.gather. Failed closes are retried 3 times with backoff. CRITICAL logs emitted for stuck positions with details for manual intervention. Stop callback invoked after close attempt. Tests cover success, partial failure, empty positions, and double-trigger cases.</done>
</task>

</tasks>

<verification>
1. `cd /Users/luckleineschaars/repos/funding-rate-arbitrage && .venv/bin/python -m pytest tests/test_risk/ -v` -- all risk tests pass
2. `cd /Users/luckleineschaars/repos/funding-rate-arbitrage && .venv/bin/python -m pytest tests/ -x -q` -- full suite passes (no regressions)
3. `cd /Users/luckleineschaars/repos/funding-rate-arbitrage && .venv/bin/ruff check src/bot/risk/` -- no lint errors
4. `cd /Users/luckleineschaars/repos/funding-rate-arbitrage && .venv/bin/python -c "from bot.risk.manager import RiskManager; from bot.risk.emergency import EmergencyController; print('imports OK')"` -- both importable
</verification>

<success_criteria>
- RiskManager.check_can_open enforces per-pair size (RISK-01), max positions (RISK-02), duplicate pair prevention
- RiskManager.check_margin_ratio returns (ratio, is_alert) from exchange data (RISK-05)
- EmergencyController.trigger closes all positions concurrently (RISK-03)
- EmergencyController retries failed closes 3 times with backoff
- CRITICAL logs emitted for positions that fail all retries
- All existing Phase 1 tests still pass
- New tests cover all risk check scenarios and emergency edge cases
</success_criteria>

<output>
After completion, create `.planning/phases/02-multi-pair-intelligence/02-03-SUMMARY.md`
</output>
