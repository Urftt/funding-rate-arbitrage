---
phase: 01-core-trading-engine
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/bot/exchange/client.py
  - src/bot/exchange/bybit_client.py
  - src/bot/exchange/types.py
  - src/bot/market_data/funding_monitor.py
  - src/bot/market_data/ticker_service.py
  - tests/test_exchange/__init__.py
  - tests/test_exchange/test_bybit_client.py
  - tests/test_market_data/__init__.py
  - tests/test_market_data/test_funding_monitor.py
autonomous: true

must_haves:
  truths:
    - "Exchange client connects to Bybit and fetches perpetual ticker data including funding rates"
    - "Funding monitor streams real-time funding rates via WebSocket with REST fallback"
    - "All perpetual pairs' funding rates are accessible, sorted by rate descending"
    - "Instrument constraints (lot size, tick size, min notional) are available for any symbol"
  artifacts:
    - path: "src/bot/exchange/client.py"
      provides: "Abstract exchange client interface"
      exports: ["ExchangeClient"]
    - path: "src/bot/exchange/bybit_client.py"
      provides: "Bybit implementation via ccxt async"
      exports: ["BybitClient"]
    - path: "src/bot/market_data/funding_monitor.py"
      provides: "Funding rate streaming and caching"
      exports: ["FundingMonitor"]
    - path: "src/bot/market_data/ticker_service.py"
      provides: "Shared price cache for paper executor and other consumers"
      exports: ["TickerService"]
  key_links:
    - from: "src/bot/exchange/bybit_client.py"
      to: "ccxt.async_support.bybit"
      via: "ccxt async client initialization"
      pattern: "ccxt\\.async_support"
    - from: "src/bot/market_data/funding_monitor.py"
      to: "src/bot/exchange/bybit_client.py"
      via: "fetches tickers via exchange client"
      pattern: "exchange.*fetch_tickers|watch_tickers"
    - from: "src/bot/market_data/ticker_service.py"
      to: "src/bot/models.py"
      via: "stores prices as Decimal in shared cache"
      pattern: "Decimal"
---

<objective>
Build the exchange client layer (Bybit via ccxt async) and the funding rate monitoring system that streams real-time funding rates for all perpetual pairs.

Purpose: This is the market data foundation. The funding monitor provides the signal (which pairs have profitable funding rates), and the exchange client provides the interface for all Bybit API operations. The ticker service provides a shared price cache that the paper executor (Plan 04) will use for realistic simulated fills.

Output: Working Bybit exchange client, real-time funding rate monitor, shared price cache, and tests with mocked exchange responses.
</objective>

<execution_context>
@/Users/luckleineschaars/.claude/get-shit-done/workflows/execute-plan.md
@/Users/luckleineschaars/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-core-trading-engine/01-RESEARCH.md
@.planning/phases/01-core-trading-engine/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement exchange client interface and Bybit implementation</name>
  <files>
    src/bot/exchange/client.py
    src/bot/exchange/bybit_client.py
    src/bot/exchange/types.py
    tests/test_exchange/__init__.py
    tests/test_exchange/test_bybit_client.py
  </files>
  <action>
    **exchange/types.py** -- Exchange-specific type definitions:
    - `InstrumentInfo` dataclass: symbol (str), min_qty (Decimal), max_qty (Decimal), qty_step (Decimal), min_notional (Decimal), tick_size (Decimal)
    - Helper function `round_to_step(value: Decimal, step: Decimal) -> Decimal` that rounds DOWN to nearest step increment using `(value // step) * step`

    **exchange/client.py** -- Abstract base class defining the exchange interface:
    ```python
    class ExchangeClient(ABC):
        @abstractmethod
        async def connect(self) -> None: ...
        @abstractmethod
        async def close(self) -> None: ...
        @abstractmethod
        async def fetch_ticker(self, symbol: str) -> dict: ...
        @abstractmethod
        async def fetch_tickers(self, symbols: list[str] | None = None, params: dict | None = None) -> dict: ...
        @abstractmethod
        async def fetch_perpetual_symbols(self) -> list[str]: ...
        @abstractmethod
        async def get_instrument_info(self, symbol: str) -> InstrumentInfo: ...
        @abstractmethod
        async def create_order(self, symbol: str, order_type: str, side: str, amount: float, price: float | None = None, params: dict | None = None) -> dict: ...
        @abstractmethod
        async def cancel_order(self, order_id: str, symbol: str, params: dict | None = None) -> dict: ...
        @abstractmethod
        async def fetch_balance(self) -> dict: ...
        @abstractmethod
        async def load_markets(self) -> dict: ...
    ```

    **exchange/bybit_client.py** -- Concrete Bybit implementation using ccxt async:
    - Constructor takes `ExchangeSettings` from config.
    - Initialize `ccxt.async_support.bybit` with: apiKey, secret from settings, `enableRateLimit=True`, `defaultType='swap'`.
    - If `demo_trading=True`, override URLs to `api-demo.bybit.com`.
    - `connect()`: call `load_markets()` to cache instrument info.
    - `close()`: call `await self.exchange.close()` (CRITICAL for ccxt async cleanup).
    - `fetch_perpetual_symbols()`: filter `self.exchange.markets` for linear perpetual symbols (`market['linear'] and market['swap']`), return list of ccxt symbol strings.
    - `get_instrument_info()`: extract from cached markets, return `InstrumentInfo` with Decimal values.
    - All other methods delegate to the underlying ccxt exchange instance.
    - Use structlog for all logging (connection events, errors, rate limit warnings).

    **tests/test_exchange/test_bybit_client.py**:
    - Test `get_instrument_info` returns correct Decimal values from mocked market data.
    - Test `fetch_perpetual_symbols` filters correctly (include linear+swap, exclude spot, exclude inverse).
    - Test `round_to_step` with various values (e.g., round_to_step(Decimal("1.2345"), Decimal("0.01")) == Decimal("1.23")).
    - Mock the ccxt exchange object using pytest-mock to avoid real API calls.
  </action>
  <verify>
    Run: `cd /Users/luckleineschaars/repos/funding-rate-arbitrage && python -m pytest tests/test_exchange/ -v`
    All tests pass.
    Run: `python -c "from bot.exchange.bybit_client import BybitClient; print('import OK')"`
  </verify>
  <done>
    BybitClient wraps ccxt async Bybit with proper initialization, market loading, instrument info extraction, and async cleanup. ExchangeClient ABC defines the interface. Tests pass with mocked exchange data.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement funding rate monitor and shared ticker service</name>
  <files>
    src/bot/market_data/funding_monitor.py
    src/bot/market_data/ticker_service.py
    tests/test_market_data/__init__.py
    tests/test_market_data/test_funding_monitor.py
  </files>
  <action>
    **market_data/ticker_service.py** -- Shared in-memory price cache:
    - `TickerService` class with `asyncio.Lock` for thread-safe reads/writes.
    - `update_price(symbol: str, price: Decimal, timestamp: float)` -- stores latest price.
    - `get_price(symbol: str) -> Decimal | None` -- returns latest cached price.
    - `get_price_age(symbol: str) -> float | None` -- returns seconds since last update.
    - `is_stale(symbol: str, max_age_seconds: float = 60.0) -> bool` -- True if price is older than max_age or missing.
    - Internal storage: `dict[str, tuple[Decimal, float]]` (price, timestamp).
    - This solves Open Question #3 from research: shared price cache between funding monitor and paper executor without tight coupling.

    **market_data/funding_monitor.py** -- Streams funding rates for all perpetual pairs:
    - Constructor takes `ExchangeClient` and `TickerService`.
    - `_funding_rates: dict[str, FundingRateData]` -- internal cache of latest funding rates.
    - `async start()` -- begins streaming. Creates background task for `_stream_loop()`.
    - `async stop()` -- sets `_running = False`, cancels background task gracefully.
    - `_stream_loop()`:
      1. Fetch all perpetual symbols via exchange client.
      2. Call `exchange.fetch_tickers(params={'category': 'linear'})` via REST (primary method for initial load).
      3. Parse each ticker: extract `fundingRate`, `nextFundingTime`, `fundingIntervalHour` from `ticker['info']`, `last` price.
      4. Convert to `FundingRateData` model (from models.py). Store in `_funding_rates`.
      5. Update `TickerService` with latest prices.
      6. Sleep for `poll_interval` seconds (default 30s), then repeat.
      7. Wrap in try/except with structlog warning on errors, retry after sleep.
    - NOTE: Use REST polling initially (not WebSocket). The research confirms funding rates change slowly (every 8h), so 30-second REST polling is sufficient for Phase 1. WebSocket streaming can be added in Phase 2 for lower latency. This avoids the complexity of ccxt Pro WebSocket management and the Open Question #1 about delta message reliability.
    - `get_all_funding_rates() -> list[FundingRateData]` -- returns cached rates sorted by rate descending.
    - `get_funding_rate(symbol: str) -> FundingRateData | None` -- returns rate for specific symbol.
    - `get_profitable_pairs(min_rate: Decimal) -> list[FundingRateData]` -- returns pairs above threshold, sorted descending.

    **tests/test_market_data/test_funding_monitor.py**:
    - Test `get_all_funding_rates` returns sorted results.
    - Test `get_profitable_pairs` filters below threshold.
    - Test ticker parsing extracts funding rate as Decimal correctly.
    - Test stale price detection in TickerService.
    - Mock exchange client to return sample ticker data.
  </action>
  <verify>
    Run: `cd /Users/luckleineschaars/repos/funding-rate-arbitrage && python -m pytest tests/test_market_data/ -v`
    All tests pass.
    Run: `python -c "from bot.market_data.funding_monitor import FundingMonitor; print('import OK')"`
    Run: `python -c "from bot.market_data.ticker_service import TickerService; print('import OK')"`
  </verify>
  <done>
    FundingMonitor fetches and caches funding rates for all perpetual pairs via REST polling. TickerService provides shared price cache with staleness detection. get_profitable_pairs filters by minimum rate. Tests pass with mocked data.
  </done>
</task>

</tasks>

<verification>
1. `python -m pytest tests/test_exchange/ tests/test_market_data/ -v` -- all tests pass
2. Exchange client ABC defines clear interface. Bybit client implements all methods.
3. FundingMonitor correctly parses funding rates from ccxt ticker format into FundingRateData models.
4. TickerService provides thread-safe shared price cache.
5. All monetary values use Decimal (no float for prices, rates, quantities).
6. Proper async cleanup via `close()` method on BybitClient.
7. InstrumentInfo provides lot constraints needed for position sizing (Plan 03).
</verification>

<success_criteria>
- BybitClient wraps ccxt async with proper initialization and cleanup
- FundingMonitor caches real-time funding rates for all perpetual pairs (MKTD-01)
- TickerService provides shared price cache for paper executor consumption
- InstrumentInfo provides position sizing constraints
- All tests pass with mocked exchange data
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-trading-engine/01-02-SUMMARY.md`
</output>
