---
phase: 01-core-trading-engine
plan: 05
type: execute
wave: 4
depends_on: ["01-04"]
files_modified:
  - src/bot/pnl/tracker.py
  - src/bot/orchestrator.py
  - src/bot/main.py
  - tests/test_pnl/test_tracker.py
  - tests/test_orchestrator.py
autonomous: true

must_haves:
  truths:
    - "P&L tracker computes realized P&L, unrealized P&L, and cumulative funding payments per position"
    - "P&L tracker simulates funding fee settlement every 8 hours for paper trading positions"
    - "Orchestrator wires all components together and runs the main bot loop"
    - "Bot starts in paper mode, connects to exchange, monitors funding rates, and can open/close positions"
    - "Full integration test demonstrates: start bot -> see funding rates -> open position -> receive simulated funding -> close position -> see P&L"
  artifacts:
    - path: "src/bot/pnl/tracker.py"
      provides: "P&L tracking with funding simulation"
      exports: ["PnLTracker"]
    - path: "src/bot/orchestrator.py"
      provides: "Main bot loop integrating all components"
      exports: ["Orchestrator"]
    - path: "src/bot/main.py"
      provides: "Entry point wiring settings to orchestrator"
      exports: ["main"]
  key_links:
    - from: "src/bot/pnl/tracker.py"
      to: "src/bot/pnl/fee_calculator.py"
      via: "calculates funding payments using FeeCalculator"
      pattern: "fee_calculator.*calculate_funding_payment"
    - from: "src/bot/pnl/tracker.py"
      to: "src/bot/market_data/ticker_service.py"
      via: "uses current prices for unrealized P&L"
      pattern: "ticker_service.*get_price"
    - from: "src/bot/orchestrator.py"
      to: "src/bot/position/manager.py"
      via: "delegates position operations"
      pattern: "position_manager.*open_position|close_position"
    - from: "src/bot/orchestrator.py"
      to: "src/bot/market_data/funding_monitor.py"
      via: "reads funding rates to find opportunities"
      pattern: "funding_monitor.*get_profitable_pairs|get_all_funding_rates"
    - from: "src/bot/main.py"
      to: "src/bot/orchestrator.py"
      via: "creates and runs orchestrator"
      pattern: "Orchestrator.*run|start"
---

<objective>
Implement P&L tracking with funding fee simulation and the main orchestrator that wires all components into a working bot loop.

Purpose: This is the integration layer -- PAPR-03 (P&L tracking with fees and funding) and the overall Phase 1 goal of a working paper trading bot. The orchestrator is the brain that monitors funding rates, decides when to open/close positions, and coordinates all subsystems.

Output: Complete paper trading bot that can run, monitor funding rates, execute simulated trades, track P&L with funding, and demonstrate the full arbitrage lifecycle.
</objective>

<execution_context>
@/Users/luckleineschaars/.claude/get-shit-done/workflows/execute-plan.md
@/Users/luckleineschaars/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-core-trading-engine/01-RESEARCH.md
@.planning/phases/01-core-trading-engine/01-04-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement P&L tracker with funding fee simulation</name>
  <files>
    src/bot/pnl/tracker.py
    tests/test_pnl/test_tracker.py
  </files>
  <action>
    **pnl/tracker.py** -- Tracks P&L across all open and closed positions:

    `PnLTracker` takes `FeeCalculator`, `TickerService`, and `FeeSettings`.

    Internal state:
    - `_position_pnl: dict[str, PositionPnL]` where `PositionPnL` is a dataclass:
      - `position_id: str`
      - `entry_fee: Decimal` (total entry fee for both legs)
      - `exit_fee: Decimal` (populated on close)
      - `funding_payments: list[FundingPayment]` (each with: amount, rate, mark_price, timestamp)
      - `spot_entry_price: Decimal`
      - `perp_entry_price: Decimal`
      - `quantity: Decimal`
      - `opened_at: float`
      - `closed_at: float | None`

    Methods:
    - `record_open(position: Position, entry_fee: Decimal)`: Initialize PositionPnL for a new position.

    - `record_close(position_id: str, spot_exit_price: Decimal, perp_exit_price: Decimal, exit_fee: Decimal)`: Finalize the position P&L.

    - `record_funding_payment(position_id: str, funding_rate: Decimal, mark_price: Decimal, quantity: Decimal)`:
      1. Calculate payment via `fee_calculator.calculate_funding_payment(quantity, mark_price, funding_rate, is_short=True)`.
      2. Append to position's funding_payments list.
      3. Log the payment with structlog.

    - `simulate_funding_settlement(positions: list[Position], funding_rates: dict[str, FundingRateData])`:
      Called by orchestrator on schedule (every 8h simulated, or when funding time passes).
      For each position, look up current funding rate, compute payment, record it.

    - `get_unrealized_pnl(position_id: str) -> Decimal`:
      1. Get current spot and perp prices from TickerService.
      2. Spot P&L: (current_spot_price - spot_entry_price) * quantity (we're long spot).
      3. Perp P&L: (perp_entry_price - current_perp_price) * quantity (we're short perp).
      4. Total unrealized = spot_pnl + perp_pnl (should be near zero for delta-neutral).
      5. NOTE: This excludes fees and funding -- those are tracked separately.

    - `get_total_pnl(position_id: str) -> dict`:
      Returns breakdown: `{unrealized_pnl, total_funding, total_fees, net_pnl}` where:
      - total_funding = sum of all funding payments
      - total_fees = entry_fee + exit_fee (exit_fee=0 if still open)
      - net_pnl = unrealized_pnl + total_funding - total_fees

    - `get_portfolio_summary() -> dict`:
      Aggregates across all positions: total_unrealized, total_funding_collected, total_fees_paid, net_portfolio_pnl.

    **tests/test_pnl/test_tracker.py**:
    - Test record_open initializes position P&L correctly.
    - Test record_funding_payment accumulates funding (positive for collecting).
    - Test get_unrealized_pnl calculates correctly when prices move.
    - Test get_total_pnl returns correct breakdown (funding income minus fees).
    - Test net P&L is positive when funding > fees (the profitable scenario).
    - Test net P&L is negative when funding < fees (unprofitable scenario).
    - Test portfolio summary aggregates multiple positions.
    - Mock TickerService for controlled price scenarios.
  </action>
  <verify>
    Run: `cd /Users/luckleineschaars/repos/funding-rate-arbitrage && python -m pytest tests/test_pnl/ -v`
    All tests pass.
    Run: `python -c "from bot.pnl.tracker import PnLTracker; print('import OK')"`
  </verify>
  <done>
    PnLTracker records position P&L including entry/exit fees, funding payments, and unrealized P&L. Funding simulation works for paper trading. get_total_pnl provides full breakdown. Tests verify profitability calculations.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement orchestrator and wire main entry point</name>
  <files>
    src/bot/orchestrator.py
    src/bot/main.py
    tests/test_orchestrator.py
  </files>
  <action>
    **orchestrator.py** -- Main bot loop (state machine):

    `Orchestrator` takes all dependencies via constructor:
    - `settings: AppSettings`
    - `exchange_client: ExchangeClient`
    - `funding_monitor: FundingMonitor`
    - `ticker_service: TickerService`
    - `position_manager: PositionManager`
    - `pnl_tracker: PnLTracker`
    - `delta_validator: DeltaValidator`
    - `fee_calculator: FeeCalculator`

    State: `_running: bool`, `_last_funding_check: float`.

    `async run()` -- Main loop:
    ```
    while self._running:
        try:
            # 1. Let funding monitor refresh rates (it runs on its own schedule)
            #    Just read the cached data
            profitable_pairs = self.funding_monitor.get_profitable_pairs(
                self.settings.trading.min_funding_rate
            )

            # 2. Log current opportunities
            if profitable_pairs:
                logger.info("profitable_pairs_found", count=len(profitable_pairs),
                           top_pair=profitable_pairs[0].symbol,
                           top_rate=str(profitable_pairs[0].rate))

            # 3. Check existing positions for delta validity
            for position in self.position_manager.get_open_positions():
                # In Phase 1, just log delta status. Phase 2 adds auto-rebalancing.
                pnl = self.pnl_tracker.get_total_pnl(position.id)
                logger.info("position_status",
                           position_id=position.id,
                           symbol=position.perp_symbol,
                           net_pnl=str(pnl['net_pnl']),
                           funding_collected=str(pnl['total_funding']))

            # 4. Simulate funding settlement if 8h has passed
            self._check_funding_settlement()

            # 5. Sleep before next iteration
            await asyncio.sleep(self.settings.trading.scan_interval or 60)

        except asyncio.CancelledError:
            break
        except Exception as e:
            logger.error("orchestrator_error", error=str(e), exc_info=True)
            await asyncio.sleep(10)
    ```

    NOTE: Phase 1 orchestrator is deliberately simple -- it monitors and logs. It does NOT auto-open positions. Opening/closing is manual via the API that will be added in Phase 2. The orchestrator proves that all components wire together and the data flows correctly. Phase 2 adds autonomous trading logic.

    `_check_funding_settlement()`:
    - Track last funding settlement time.
    - If 8 hours have elapsed since last settlement (or since position was opened):
      - Call `pnl_tracker.simulate_funding_settlement()` with open positions and current funding rates.
      - Update last_funding_check.

    `async start()`: Start funding monitor, run main loop.
    `async stop()`: Set _running=False, stop funding monitor, close exchange client.

    Add convenience methods for manual operation (Phase 1 usage):
    - `async open_position(spot_symbol: str, perp_symbol: str) -> Position`: wraps position_manager.open_position with balance fetch and instrument lookup.
    - `async close_position(position_id: str)`: wraps position_manager.close_position and records in pnl_tracker.
    - `get_status() -> dict`: returns current state (running, open positions count, funding monitor status).

    **main.py** -- Updated entry point:
    Wire all components:
    1. Load `AppSettings()`
    2. Setup logging
    3. Create `BybitClient` from settings (or a mock client for pure paper mode without API keys)
    4. Create `TickerService`
    5. Create `FundingMonitor(exchange_client, ticker_service)`
    6. Create `FeeCalculator(settings.fees)`
    7. Create `PositionSizer(settings.trading)`
    8. Create `DeltaValidator(settings.trading)`
    9. Create executor: `PaperExecutor(ticker_service, settings.fees)` if mode=="paper", else `LiveExecutor(exchange_client)`
    10. Create `PositionManager(executor, position_sizer, fee_calculator, delta_validator, ticker_service, settings.trading)`
    11. Create `PnLTracker(fee_calculator, ticker_service, settings.fees)`
    12. Create `Orchestrator(settings, exchange_client, funding_monitor, ticker_service, position_manager, pnl_tracker, delta_validator, fee_calculator)`
    13. Handle SIGINT/SIGTERM for graceful shutdown: `orchestrator.stop()`
    14. Run: `await orchestrator.start()`

    If mode is "paper" and no API keys are provided, the exchange client should still work for public endpoints (market data). ccxt allows public API calls without authentication. Log a warning if API keys are empty and mode is "paper" -- it's fine for paper mode.

    **tests/test_orchestrator.py**:
    - Test orchestrator initializes and can be started/stopped.
    - Test funding settlement simulation triggers after 8h elapsed.
    - Test open_position convenience method calls through to position_manager.
    - Test get_status returns correct structure.
    - Mock all dependencies.
  </action>
  <verify>
    Run: `cd /Users/luckleineschaars/repos/funding-rate-arbitrage && python -m pytest tests/test_orchestrator.py -v`
    All tests pass.
    Run: `python -m pytest tests/ -v --tb=short` (full test suite)
    All tests pass.
    Run: `python -c "from bot.orchestrator import Orchestrator; print('orchestrator import OK')"`
    Run: `python -c "from bot.main import main; print('main import OK')"`
  </verify>
  <done>
    Orchestrator wires all components and runs the main bot loop. P&L tracker simulates funding settlements. main.py creates the full dependency graph and starts the bot. All tests pass including full test suite. The bot can start in paper mode, monitor funding rates, and manually open/close positions with full P&L tracking.
  </done>
</task>

</tasks>

<verification>
1. `python -m pytest tests/ -v` -- full test suite passes (all plans' tests)
2. `python -c "from bot.main import main"` -- entry point importable
3. Orchestrator correctly wires: settings -> exchange -> funding monitor -> executor -> position manager -> P&L tracker
4. P&L tracker accumulates funding payments and computes net P&L (PAPR-03)
5. Funding settlement simulation triggers on 8h intervals
6. Portfolio summary aggregates across all positions
7. Graceful shutdown handled via SIGINT/SIGTERM
</verification>

<success_criteria>
- P&L tracker computes correct net P&L including fees and funding (PAPR-03)
- Funding fee simulation runs on 8h schedule for paper positions
- Orchestrator integrates all components into a working bot loop
- Bot starts in paper mode without real API keys (public endpoints only)
- Full test suite passes
- Entry point (main.py) creates complete dependency graph
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-trading-engine/01-05-SUMMARY.md`
</output>
