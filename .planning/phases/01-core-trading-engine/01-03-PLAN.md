---
phase: 01-core-trading-engine
plan: 03
type: tdd
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/bot/pnl/fee_calculator.py
  - src/bot/position/sizing.py
  - tests/test_pnl/__init__.py
  - tests/test_pnl/test_fee_calculator.py
  - tests/test_position/__init__.py
  - tests/test_position/test_sizing.py
autonomous: true

must_haves:
  truths:
    - "Fee calculator correctly computes entry fees, exit fees, and total round-trip cost for spot+perp trades"
    - "Fee calculator determines minimum funding rate needed to break even within a given time horizon"
    - "Position sizer calculates maximum quantity respecting balance, leverage, lot constraints, and minimum notional"
    - "Position sizer uses Decimal throughout -- no float arithmetic for any monetary calculation"
    - "Profitability check correctly determines if a trade is worth entering given fees and expected funding"
  artifacts:
    - path: "src/bot/pnl/fee_calculator.py"
      provides: "Fee computation and profitability analysis"
      exports: ["FeeCalculator"]
    - path: "src/bot/position/sizing.py"
      provides: "Position size calculation with exchange constraints"
      exports: ["PositionSizer"]
    - path: "tests/test_pnl/test_fee_calculator.py"
      provides: "TDD tests for fee calculator"
      min_lines: 60
    - path: "tests/test_position/test_sizing.py"
      provides: "TDD tests for position sizer"
      min_lines: 60
  key_links:
    - from: "src/bot/pnl/fee_calculator.py"
      to: "src/bot/config.py"
      via: "FeeSettings for maker/taker rates"
      pattern: "FeeSettings|fee_rate"
    - from: "src/bot/position/sizing.py"
      to: "src/bot/exchange/types.py"
      via: "InstrumentInfo for lot constraints"
      pattern: "InstrumentInfo|qty_step|min_qty"
---

<objective>
Implement fee calculation and position sizing using test-driven development. These are pure business logic modules with well-defined inputs and outputs -- ideal TDD candidates.

Purpose: EXEC-03 (Decimal precision position sizing) and EXEC-04 (fee accounting for profitability) are the mathematical core of the bot. Errors here directly cause losses. TDD ensures correctness with concrete numerical examples before any integration.

Output: Tested fee calculator and position sizer with full Decimal arithmetic, ready for use by the executor and orchestrator.
</objective>

<execution_context>
@/Users/luckleineschaars/.claude/get-shit-done/workflows/execute-plan.md
@/Users/luckleineschaars/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-core-trading-engine/01-RESEARCH.md
@.planning/phases/01-core-trading-engine/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Feature 1: Fee calculator with profitability analysis</name>
  <files>
    src/bot/pnl/fee_calculator.py
    tests/test_pnl/__init__.py
    tests/test_pnl/test_fee_calculator.py
  </files>
  <action>
    TDD approach: Write tests first (RED), then implement (GREEN), then refactor.

    **FeeCalculator class** takes `FeeSettings` in constructor. All methods use Decimal arithmetic exclusively -- no float conversions anywhere.

    **Test cases to write FIRST (RED phase):**

    Entry fee calculation (spot taker 0.1% + perp taker 0.055%):
    - `calculate_entry_fee(quantity=Decimal("1.0"), spot_price=Decimal("50000"), perp_price=Decimal("50000"))` -> `Decimal("77.50")` (50000*0.001 + 50000*0.00055 = 50 + 27.5)
    - `calculate_entry_fee(quantity=Decimal("0.5"), spot_price=Decimal("3000"), perp_price=Decimal("3010"))` -> `Decimal("2.32775")` (1500*0.001 + 1505*0.00055 = 1.5 + 0.82775)

    Exit fee calculation (same rates):
    - `calculate_exit_fee(quantity=Decimal("1.0"), spot_price=Decimal("51000"), perp_price=Decimal("49000"))` -> `Decimal("77.95")` (51000*0.001 + 49000*0.00055 = 51 + 26.95)

    Total round-trip fee:
    - `calculate_round_trip_fee(quantity, spot_entry_price, perp_entry_price, spot_exit_price, perp_exit_price)` -> entry_fee + exit_fee

    Break-even funding rate:
    - `min_funding_rate_for_breakeven(quantity=Decimal("1.0"), entry_price=Decimal("50000"), round_trip_fee=Decimal("155"), funding_periods=3)` -> ~`Decimal("0.001033")` (155 / (50000 * 3) = 0.001033...)
    - This answers: "What minimum 8h funding rate do I need to break even in N funding periods?"

    Profitability check:
    - `is_profitable(funding_rate=Decimal("0.001"), quantity=Decimal("1.0"), entry_price=Decimal("50000"), min_periods=3)` -> False (expected funding = 150 < round-trip fee ~155)
    - `is_profitable(funding_rate=Decimal("0.001"), quantity=Decimal("1.0"), entry_price=Decimal("50000"), min_periods=4)` -> True (200 > 155)

    Funding payment calculation (Bybit convention: positive rate = longs pay shorts):
    - `calculate_funding_payment(position_qty=Decimal("1.0"), mark_price=Decimal("50000"), funding_rate=Decimal("0.001"), is_short=True)` -> `Decimal("50")` (positive = income for short)
    - `calculate_funding_payment(position_qty=Decimal("1.0"), mark_price=Decimal("50000"), funding_rate=Decimal("0.001"), is_short=False)` -> `Decimal("-50")` (negative = expense for long)
    - `calculate_funding_payment(position_qty=Decimal("1.0"), mark_price=Decimal("50000"), funding_rate=Decimal("-0.0005"), is_short=True)` -> `Decimal("-25")` (negative rate = shorts pay longs)

    **Implementation (GREEN phase):**
    `calculate_funding_payment` encodes Bybit convention per research Pitfall #1. When `is_short=True` and rate is positive, return positive value (income). Add a clear comment documenting the convention.

    `is_profitable` computes: expected_funding = position_value * funding_rate * min_periods, compares against round_trip_fee. Return True if expected_funding > round_trip_fee.
  </action>
  <verify>
    Run: `cd /Users/luckleineschaars/repos/funding-rate-arbitrage && python -m pytest tests/test_pnl/test_fee_calculator.py -v`
    All tests pass. Verify no `float()` calls in fee_calculator.py.
  </verify>
  <done>
    FeeCalculator computes entry/exit/round-trip fees, break-even funding rate, profitability check, and funding payments -- all with Decimal precision. All test cases pass with exact expected values. Bybit funding convention correctly encoded.
  </done>
</task>

<task type="auto">
  <name>Feature 2: Position sizer with exchange constraint validation</name>
  <files>
    src/bot/position/sizing.py
    tests/test_position/__init__.py
    tests/test_position/test_sizing.py
  </files>
  <action>
    TDD approach: Write tests first (RED), then implement (GREEN), then refactor.

    **Test cases to write FIRST (RED phase):**

    Basic position sizing (max_position_size_usd=1000):
    - `calculate_quantity(price=Decimal("50000"), available_balance=Decimal("10000"), instrument=InstrumentInfo(min_qty=Decimal("0.001"), qty_step=Decimal("0.001"), ...))` -> `Decimal("0.020")` (1000/50000 = 0.02, rounded to step)
    - `calculate_quantity(price=Decimal("3"), available_balance=Decimal("10000"), instrument=InstrumentInfo(min_qty=Decimal("1"), qty_step=Decimal("1"), ...))` -> `Decimal("333")` (1000/3 = 333.33, rounded down to step=1)

    Balance-limited:
    - `calculate_quantity(price=Decimal("50000"), available_balance=Decimal("500"), instrument=...)` -> `Decimal("0.010")` (limited by balance, not max_position_size: 500/50000 = 0.01)

    Below minimum:
    - `calculate_quantity(price=Decimal("50000"), available_balance=Decimal("10"), instrument=InstrumentInfo(min_qty=Decimal("0.001"), ...))` -> `None` (10/50000 = 0.0002, below min_qty=0.001)

    Min notional check:
    - `calculate_quantity(price=Decimal("0.01"), available_balance=Decimal("10000"), instrument=InstrumentInfo(min_notional=Decimal("10"), min_qty=Decimal("1"), qty_step=Decimal("1"), ...))` -> quantity such that qty * price >= min_notional

    Step rounding:
    - `calculate_quantity(price=Decimal("100"), available_balance=Decimal("10000"), instrument=InstrumentInfo(qty_step=Decimal("0.1"), min_qty=Decimal("0.1"), ...))` -> `Decimal("10.0")`

    Validate both legs match:
    - `validate_matching_quantity(spot_qty=Decimal("1.0"), perp_qty=Decimal("1.0"))` -> True
    - `validate_matching_quantity(spot_qty=Decimal("1.001"), perp_qty=Decimal("1.0"))` -> True (within step tolerance)
    - NOTE: Spot and perp may have different qty_step values. The position sizer must ensure both legs use the SAME base quantity. Calculate using the LARGER (coarser) step of the two instruments.

    **Implementation (GREEN phase):**

    `PositionSizer` class takes `TradingSettings` in constructor.

    `calculate_quantity(price, available_balance, instrument)`:
    1. max_by_config = settings.max_position_size_usd / price
    2. max_by_balance = available_balance / price (use full balance for now; Phase 2 adds margin reservation)
    3. raw_qty = min(max_by_config, max_by_balance)
    4. rounded_qty = round_to_step(raw_qty, instrument.qty_step)
    5. If rounded_qty < instrument.min_qty: return None
    6. If rounded_qty * price < instrument.min_notional: return None
    7. Return rounded_qty

    `calculate_matching_quantity(price, available_balance, spot_instrument, perp_instrument)`:
    - Compute using the coarser qty_step of the two instruments
    - Return single Decimal quantity valid for both legs

    All Decimal. Use `round_to_step` from exchange/types.py.
  </action>
  <verify>
    Run: `cd /Users/luckleineschaars/repos/funding-rate-arbitrage && python -m pytest tests/test_position/test_sizing.py -v`
    All tests pass. Verify no `float()` calls in sizing.py.
  </verify>
  <done>
    PositionSizer calculates quantities respecting max_position_size_usd, available_balance, min_qty, qty_step, and min_notional -- all with Decimal precision. calculate_matching_quantity ensures both spot and perp legs use identical base quantity. All test cases pass.
  </done>
</task>

</tasks>

<verification>
1. `python -m pytest tests/test_pnl/test_fee_calculator.py -v` -- all fee calculator tests pass
2. `python -m pytest tests/test_position/test_sizing.py -v` -- all sizing tests pass
3. Verify no `float()` calls in fee_calculator.py or sizing.py (grep for "float(")
4. Fee calculator correctly encodes: positive funding rate + short position = income (Bybit convention)
5. Position sizer respects min_qty, qty_step, min_notional, max_position_size_usd, and available_balance
6. Round-trip fee calculation matches research numbers: ~0.31% for taker orders at base tier
</verification>

<success_criteria>
- Fee calculator computes entry/exit/round-trip fees correctly (EXEC-04)
- Funding payment calculation follows Bybit convention (positive = longs pay shorts)
- Position sizer respects all exchange constraints with Decimal precision (EXEC-03)
- Profitability check determines if trade is worth entering given fees and expected funding
- All tests pass with concrete numerical examples
- Zero float usage in monetary calculations
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-trading-engine/01-03-SUMMARY.md`
</output>
