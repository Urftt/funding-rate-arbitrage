---
phase: 08-pair-analysis-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/bot/analytics/pair_analyzer.py
  - src/bot/dashboard/routes/api.py
  - src/bot/dashboard/app.py
  - src/bot/main.py
autonomous: true

must_haves:
  truths:
    - "PairAnalyzer computes fee-adjusted annualized yield, avg rate, median, std dev, and pct positive for each tracked pair"
    - "Pairs with fewer than 30 funding records are flagged as insufficient data"
    - "API endpoint /api/pairs/ranking returns all pairs ranked by annualized yield descending"
    - "API endpoint /api/pairs/{symbol}/stats returns per-pair time series data and statistics"
    - "Date range filtering (7d, 30d, 90d, all) works via query parameter on both endpoints"
  artifacts:
    - path: "src/bot/analytics/pair_analyzer.py"
      provides: "PairAnalyzer service, PairStats and PairDetail dataclasses"
      min_lines: 80
    - path: "src/bot/dashboard/routes/api.py"
      provides: "GET /api/pairs/ranking and GET /api/pairs/{symbol}/stats endpoints"
      contains: "pairs/ranking"
    - path: "src/bot/dashboard/app.py"
      provides: "PairAnalyzer placeholder on app.state"
      contains: "pair_analyzer"
    - path: "src/bot/main.py"
      provides: "PairAnalyzer wiring in lifespan with data_store and fee_settings"
      contains: "PairAnalyzer"
  key_links:
    - from: "src/bot/analytics/pair_analyzer.py"
      to: "src/bot/data/store.py"
      via: "HistoricalDataStore.get_funding_rates() and get_tracked_pairs()"
      pattern: "get_funding_rates|get_tracked_pairs"
    - from: "src/bot/analytics/pair_analyzer.py"
      to: "src/bot/config.py"
      via: "FeeSettings for yield calculation"
      pattern: "FeeSettings"
    - from: "src/bot/dashboard/routes/api.py"
      to: "src/bot/analytics/pair_analyzer.py"
      via: "request.app.state.pair_analyzer"
      pattern: "pair_analyzer"
---

<objective>
Build the PairAnalyzer backend service that computes per-pair historical funding rate statistics and fee-adjusted yields, expose it via two API endpoints, and wire it into the dashboard app.

Purpose: Provides the data layer for the Pair Explorer feature. All statistical computation and data retrieval happens here -- the UI plans (08-02, 08-03) only need to consume these JSON APIs.

Output: PairAnalyzer service class, PairStats/PairDetail dataclasses, /api/pairs/ranking and /api/pairs/{symbol}/stats endpoints, app.state wiring.
</objective>

<execution_context>
@/Users/luckleineschaars/.claude/get-shit-done/workflows/execute-plan.md
@/Users/luckleineschaars/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/bot/data/store.py
@src/bot/data/models.py
@src/bot/market_data/opportunity_ranker.py
@src/bot/config.py
@src/bot/analytics/metrics.py
@src/bot/dashboard/routes/api.py
@src/bot/dashboard/app.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: PairAnalyzer service class with PairStats and PairDetail dataclasses</name>
  <files>src/bot/analytics/pair_analyzer.py</files>
  <action>
Create `src/bot/analytics/pair_analyzer.py` with:

1. **PairStats dataclass** with fields:
   - `symbol: str`
   - `record_count: int`
   - `avg_rate: Decimal`
   - `median_rate: Decimal`
   - `std_dev: Decimal`
   - `pct_positive: Decimal` (fraction of records where funding_rate > 0)
   - `net_yield_per_period: Decimal` (avg_rate minus amortized round-trip fee)
   - `annualized_yield: Decimal` (net_yield * 8760 / interval_hours)
   - `has_sufficient_data: bool` (True if record_count >= MIN_RECORDS)
   - A `to_dict()` method returning all fields with Decimal values as `str()`

2. **PairDetail dataclass** with fields:
   - `symbol: str`
   - `stats: PairStats`
   - `time_series: list[dict]` (each dict: `{"timestamp_ms": int, "funding_rate": str, "interval_hours": int}`)
   - A `to_dict()` method

3. **Constants:**
   - `MIN_RECORDS = 30` (~10 days at 8h intervals)
   - `_HOURS_PER_YEAR = Decimal("8760")`

4. **PairAnalyzer class:**
   - `__init__(self, data_store: HistoricalDataStore, fee_settings: FeeSettings)` storing both on self
   - `async def get_pair_ranking(self, since_ms: int | None = None, until_ms: int | None = None) -> list[PairStats]`:
     - Call `self._store.get_tracked_pairs(active_only=True)` to get all symbols
     - For each symbol, call `self._store.get_funding_rates(symbol, since_ms, until_ms)`
     - Compute statistics using `_compute_stats()` helper
     - Sort by `annualized_yield` descending, with `has_sufficient_data=False` pairs sorted to bottom
     - Return list of PairStats
   - `async def get_pair_stats(self, symbol: str, since_ms: int | None = None, until_ms: int | None = None) -> PairDetail`:
     - Call `self._store.get_funding_rates(symbol, since_ms, until_ms)`
     - Compute stats via `_compute_stats()`
     - Build time_series list from the funding rate records
     - Return PairDetail

5. **_compute_stats() private method** (on the class or module-level):
   - Takes `symbol: str`, `rates: list[HistoricalFundingRate]`, `fee_settings: FeeSettings`
   - Returns PairStats
   - If len(rates) == 0: return PairStats with all zeros and has_sufficient_data=False
   - Extract Decimal funding_rate values from rates
   - Compute avg_rate: `sum(values) / Decimal(len(values))`
   - Compute median_rate: sort values, use middle element(s) formula (same pattern as research)
   - Compute std_dev: sample standard deviation with N-1 denominator, using `Decimal.sqrt()`. If N < 2, std_dev = Decimal("0")
   - Compute pct_positive: `Decimal(count of rate > 0) / Decimal(len(values))`
   - Compute fee-adjusted yield using OpportunityRanker formula:
     ```
     round_trip_fee = (fee_settings.spot_taker + fee_settings.perp_taker) * 2
     amortized_fee = round_trip_fee / Decimal("3")  # min_holding_periods = 3
     net_yield_per_period = avg_rate - amortized_fee
     ```
   - For annualized yield, determine dominant interval_hours from the rates (most common value). Then: `annualized_yield = net_yield_per_period * (_HOURS_PER_YEAR / Decimal(str(interval_hours)))`
   - Set `has_sufficient_data = len(rates) >= MIN_RECORDS`

Use `from __future__ import annotations` at top. Import structlog for logging. Use `from bot.data.store import HistoricalDataStore` and `from bot.config import FeeSettings`.
  </action>
  <verify>
Run: `python -c "from bot.analytics.pair_analyzer import PairAnalyzer, PairStats, PairDetail; print('OK')"`
Verify it imports without error.
  </verify>
  <done>PairAnalyzer class exists with get_pair_ranking() and get_pair_stats() methods. PairStats and PairDetail dataclasses exist with to_dict() methods. Statistics computation uses Decimal arithmetic throughout. MIN_RECORDS threshold is enforced.</done>
</task>

<task type="auto">
  <name>Task 2: API endpoints, app.state placeholder, and main.py wiring</name>
  <files>src/bot/dashboard/routes/api.py, src/bot/dashboard/app.py, src/bot/main.py</files>
  <action>
**In `src/bot/dashboard/routes/api.py`**, add two new endpoints:

1. **`_range_to_since_ms()` helper function** (add before the new endpoints):
   ```python
   def _range_to_since_ms(range_str: str) -> int | None:
       """Convert date range string to since_ms timestamp."""
       if range_str == "all":
           return None
       days = {"7d": 7, "30d": 30, "90d": 90}.get(range_str)
       if days is None:
           return None
       return int(time.time() * 1000) - days * 86400 * 1000
   ```
   Add `import time` to the imports if not already present.

2. **`GET /pairs/ranking`** endpoint:
   ```python
   @router.get("/pairs/ranking")
   async def get_pair_ranking(request: Request, range: str = "all") -> JSONResponse:
   ```
   - Convert `range` param to `since_ms` using `_range_to_since_ms(range)`
   - Get `pair_analyzer` from `request.app.state.pair_analyzer`
   - If pair_analyzer is None, return `JSONResponse(content={"error": "Pair analysis not available"}, status_code=501)`
   - Call `await pair_analyzer.get_pair_ranking(since_ms=since_ms)`
   - Return `JSONResponse(content=[s.to_dict() for s in ranking])`

3. **`GET /pairs/{symbol:path}/stats`** endpoint:
   ```python
   @router.get("/pairs/{symbol:path}/stats")
   async def get_pair_stats(request: Request, symbol: str, range: str = "all") -> JSONResponse:
   ```
   - Use same `_range_to_since_ms()` helper
   - Get pair_analyzer from app.state
   - If pair_analyzer is None, return 501
   - Call `await pair_analyzer.get_pair_stats(symbol, since_ms=since_ms)`
   - Return `JSONResponse(content=detail.to_dict())`
   - Wrap in try/except for any errors, return 404 if no data found

**In `src/bot/dashboard/app.py`**, add PairAnalyzer placeholder:
- After `app.state.historical_db_path = "data/historical.db"` line, add:
  ```python
  # Pair analyzer for pair explorer (Phase 8) -- wired by main.py lifespan
  app.state.pair_analyzer = None
  ```

**In `src/bot/main.py`**, wire PairAnalyzer in the lifespan function:
- Add import at top of file: `from bot.analytics.pair_analyzer import PairAnalyzer`
- In the `lifespan()` function, after `app.state.data_store = components.get("data_store")` (around line 289), add:
  ```python
  # Wire pair analyzer for pair explorer (Phase 8)
  if components.get("data_store") is not None:
      app.state.pair_analyzer = PairAnalyzer(
          data_store=components["data_store"],
          fee_settings=settings.fees,
      )
  ```
  This creates the PairAnalyzer with the real data_store and fee_settings from AppSettings, overriding the None placeholder from app.py.
  </action>
  <verify>
Run: `python -c "from bot.dashboard.routes.api import router; print('OK')"`
Run: `python -c "from bot.dashboard.app import create_dashboard_app; app = create_dashboard_app(); print(hasattr(app.state, 'pair_analyzer'))"`
Run: `python -c "from bot.main import lifespan; print('OK')"`
All should succeed.
  </verify>
  <done>GET /api/pairs/ranking returns ranking JSON with date range filtering. GET /api/pairs/{symbol}/stats returns per-pair detail with time series data. app.state.pair_analyzer placeholder exists in app.py. PairAnalyzer is wired in main.py lifespan when data_store is available. Endpoints gracefully handle pair_analyzer being None.</done>
</task>

</tasks>

<verification>
1. `python -c "from bot.analytics.pair_analyzer import PairAnalyzer, PairStats, PairDetail; print('imports OK')"` succeeds
2. `python -c "from bot.dashboard.routes.api import router; print('api OK')"` succeeds
3. `python -c "from bot.dashboard.app import create_dashboard_app; app = create_dashboard_app(); print('pair_analyzer' in dir(app.state))"` prints True
4. `python -m pytest tests/ -x -q` -- all existing tests pass (no regressions)
</verification>

<success_criteria>
- PairAnalyzer service computes fee-adjusted annualized yield using the same formula as OpportunityRanker
- PairStats includes avg_rate, median_rate, std_dev, pct_positive, net_yield_per_period, annualized_yield
- MIN_RECORDS = 30 threshold flags pairs with insufficient data
- Two API endpoints respond to GET requests with JSON
- Date range parameter converts to since_ms for time-filtered queries
- All Decimal values serialized as strings in JSON responses
- No new Python dependencies added
</success_criteria>

<output>
After completion, create `.planning/phases/08-pair-analysis-foundation/08-01-SUMMARY.md`
</output>
