---
phase: 10-strategy-builder-visualization
plan: 03
type: execute
wave: 2
depends_on: ["10-01"]
files_modified:
  - src/bot/analytics/pair_analyzer.py
  - src/bot/data/market_cap.py
  - src/bot/dashboard/routes/api.py
  - src/bot/dashboard/routes/pages.py
  - src/bot/dashboard/templates/pairs.html
  - src/bot/dashboard/templates/base.html
autonomous: true

must_haves:
  truths:
    - "User can view a funding rate distribution histogram for any individual pair on the pairs page"
    - "User can select multiple pairs and see a cross-pair box plot comparison chart"
    - "User can filter pairs by market cap tier (mega, large, mid, small) in the ranking table"
    - "User can see a performance summary card with aggregate yield stats for the selected tier"
    - "Box plot chart auto-computes quartiles, median, and whiskers from raw funding rate data"
  artifacts:
    - path: "src/bot/analytics/pair_analyzer.py"
      provides: "get_rate_distribution() method returning histogram bins and raw rates"
      contains: "async def get_rate_distribution"
    - path: "src/bot/data/market_cap.py"
      provides: "MarketCapService with CoinGecko integration and tier classification"
      contains: "class MarketCapService"
    - path: "src/bot/dashboard/routes/api.py"
      provides: "/api/pairs/distribution and /api/market-cap endpoints"
      contains: "pairs/distribution"
    - path: "src/bot/dashboard/templates/pairs.html"
      provides: "Rate histogram, box plot chart, market cap filter, and performance summary"
      contains: "boxplot"
    - path: "src/bot/dashboard/templates/base.html"
      provides: "Boxplot CDN script tag loaded after Chart.js"
      contains: "chartjs-chart-boxplot"
  key_links:
    - from: "src/bot/dashboard/templates/pairs.html"
      to: "/api/pairs/distribution"
      via: "fetch GET when user clicks histogram button for a pair"
      pattern: "api/pairs.*distribution"
    - from: "src/bot/dashboard/templates/pairs.html"
      to: "/api/market-cap"
      via: "fetch GET on page load for tier data"
      pattern: "api/market-cap"
    - from: "src/bot/dashboard/routes/api.py"
      to: "src/bot/analytics/pair_analyzer.py"
      via: "calls pair_analyzer.get_rate_distribution()"
      pattern: "get_rate_distribution"
    - from: "src/bot/dashboard/routes/api.py"
      to: "src/bot/data/market_cap.py"
      via: "calls market_cap_service methods"
      pattern: "market_cap_service"
---

<objective>
Add funding rate distribution visualization (histograms and box plots), CoinGecko market cap tier filtering, and a performance summary card to the pairs page.

Purpose: Satisfies EXPR-04 (rate distribution histogram), EXPR-07 (cross-pair box plots), EXPR-08 (market cap tier filtering), and EXPR-09 (historical performance summary card).
Output: Extended PairAnalyzer, MarketCapService, API endpoints, and enriched pairs page UI.
</objective>

<execution_context>
@/Users/luckleineschaars/.claude/get-shit-done/workflows/execute-plan.md
@/Users/luckleineschaars/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@src/bot/analytics/pair_analyzer.py
@src/bot/data/store.py
@src/bot/dashboard/routes/api.py
@src/bot/dashboard/routes/pages.py
@src/bot/dashboard/templates/pairs.html
@src/bot/dashboard/templates/base.html

@.planning/phases/10-strategy-builder-visualization/10-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: PairAnalyzer rate distribution, MarketCapService, and API endpoints</name>
  <files>src/bot/analytics/pair_analyzer.py, src/bot/data/market_cap.py, src/bot/dashboard/routes/api.py, src/bot/dashboard/routes/pages.py, src/bot/main.py</files>
  <action>
  **PairAnalyzer extension** -- Add `get_rate_distribution()` method to `PairAnalyzer` class in `pair_analyzer.py`:

  ```python
  async def get_rate_distribution(
      self,
      symbol: str,
      since_ms: int | None = None,
      until_ms: int | None = None,
  ) -> dict:
      """Get funding rate distribution data for histogram and box plot rendering.

      Returns server-side histogram bins (for individual pair histogram) and
      raw rate values as strings (for the boxplot plugin which auto-computes
      quartiles).

      Args:
          symbol: Trading pair symbol.
          since_ms: Optional start timestamp filter.
          until_ms: Optional end timestamp filter.

      Returns:
          Dict with "bins", "counts", and "raw_rates" keys.
      """
      rates = await self._store.get_funding_rates(symbol, since_ms, until_ms)
      values = [r.funding_rate for r in rates]

      if not values:
          return {"bins": [], "counts": [], "raw_rates": []}

      # Server-side histogram binning with percentage labels
      min_val, max_val = min(values), max(values)

      if min_val == max_val:
          label = f"{float(min_val) * 100:.4f}%"
          return {"bins": [label], "counts": [len(values)], "raw_rates": [str(v) for v in values]}

      bin_count = min(20, max(5, len(values) // 20))
      bin_width = (max_val - min_val) / Decimal(str(bin_count))

      bins = []
      counts = []
      for i in range(bin_count):
          lower = min_val + bin_width * Decimal(str(i))
          label = f"{float(lower) * 100:.4f}%"
          upper = lower + bin_width
          count = sum(
              1 for v in values
              if (lower <= v < upper) or (i == bin_count - 1 and v == max_val)
          )
          bins.append(label)
          counts.append(count)

      raw_rates = [str(v) for v in values]

      return {"bins": bins, "counts": counts, "raw_rates": raw_rates}
  ```

  Also add a bulk distribution method for the box plot (fetches rates for multiple pairs):

  ```python
  async def get_multi_rate_distribution(
      self,
      symbols: list[str],
      since_ms: int | None = None,
      until_ms: int | None = None,
  ) -> dict[str, list[str]]:
      """Get raw funding rate arrays for multiple pairs (for box plot chart).

      Args:
          symbols: List of trading pair symbols.
          since_ms: Optional start timestamp filter.
          until_ms: Optional end timestamp filter.

      Returns:
          Dict mapping symbol to list of rate value strings.
      """
      result = {}
      for symbol in symbols:
          rates = await self._store.get_funding_rates(symbol, since_ms, until_ms)
          result[symbol] = [str(r.funding_rate) for r in rates]
      return result
  ```

  **MarketCapService** -- Create `src/bot/data/market_cap.py`:

  ```python
  """CoinGecko market cap service for pair tier classification.

  Fetches market cap data via the CoinGecko free API and classifies
  pairs into tiers: mega (>$50B), large ($10B-$50B), mid ($1B-$10B),
  small (<$1B). Uses urllib.request (stdlib) to avoid adding new
  Python dependencies.

  Results are cached in memory with a configurable TTL (default 1 hour)
  since market cap tiers change slowly.
  """

  import json
  import time
  import urllib.request
  from decimal import Decimal

  import structlog

  logger = structlog.get_logger(__name__)

  # Static mapping from ccxt-format symbols to CoinGecko coin IDs
  SYMBOL_TO_COINGECKO: dict[str, str] = {
      "BTC/USDT:USDT": "bitcoin",
      "ETH/USDT:USDT": "ethereum",
      "SOL/USDT:USDT": "solana",
      "XRP/USDT:USDT": "ripple",
      "DOGE/USDT:USDT": "dogecoin",
      "ADA/USDT:USDT": "cardano",
      "AVAX/USDT:USDT": "avalanche-2",
      "DOT/USDT:USDT": "polkadot",
      "LINK/USDT:USDT": "chainlink",
      "MATIC/USDT:USDT": "matic-network",
      "SHIB/USDT:USDT": "shiba-inu",
      "LTC/USDT:USDT": "litecoin",
      "UNI/USDT:USDT": "uniswap",
      "ATOM/USDT:USDT": "cosmos",
      "FIL/USDT:USDT": "filecoin",
      "APT/USDT:USDT": "aptos",
      "ARB/USDT:USDT": "arbitrum",
      "OP/USDT:USDT": "optimism",
      "SUI/USDT:USDT": "sui",
      "NEAR/USDT:USDT": "near",
      "PEPE/USDT:USDT": "pepe",
      "WIF/USDT:USDT": "dogwifcoin",
  }

  # Tier boundaries in USD
  TIER_MEGA = Decimal("50000000000")     # > $50B
  TIER_LARGE = Decimal("10000000000")    # $10B - $50B
  TIER_MID = Decimal("1000000000")       # $1B - $10B


  def _classify_tier(market_cap: Decimal) -> str:
      """Classify market cap into tier name."""
      if market_cap >= TIER_MEGA:
          return "mega"
      if market_cap >= TIER_LARGE:
          return "large"
      if market_cap >= TIER_MID:
          return "mid"
      return "small"


  class MarketCapService:
      """Fetches and caches market cap data from CoinGecko free API.

      Args:
          cache_ttl_seconds: How long to cache results (default 3600 = 1 hour).
          api_key: Optional CoinGecko demo API key for higher rate limits.
      """

      def __init__(self, cache_ttl_seconds: int = 3600, api_key: str | None = None):
          self._cache: dict[str, dict] = {}
          self._cache_time: float = 0
          self._ttl = cache_ttl_seconds
          self._api_key = api_key

      def _is_cache_valid(self) -> bool:
          return bool(self._cache) and (time.time() - self._cache_time < self._ttl)

      def _fetch_market_caps(self, coin_ids: list[str]) -> dict[str, Decimal]:
          """Fetch market caps from CoinGecko free API using stdlib urllib."""
          if not coin_ids:
              return {}

          ids_param = ",".join(coin_ids)
          url = (
              f"https://api.coingecko.com/api/v3/coins/markets"
              f"?vs_currency=usd&ids={ids_param}&per_page=250"
          )
          if self._api_key:
              url += f"&x_cg_demo_api_key={self._api_key}"

          headers = {"Accept": "application/json", "User-Agent": "FundingRateBot/1.0"}
          req = urllib.request.Request(url, headers=headers)

          try:
              with urllib.request.urlopen(req, timeout=10) as resp:
                  data = json.loads(resp.read())
              return {
                  item["id"]: Decimal(str(item.get("market_cap") or 0))
                  for item in data
              }
          except Exception as e:
              logger.warning("coingecko_fetch_error", error=str(e))
              return {}

      def get_pair_tiers(self, symbols: list[str]) -> dict[str, dict]:
          """Get market cap tier for each symbol.

          Returns a dict mapping symbol -> {"tier": str, "market_cap": str, "coingecko_id": str}.
          Symbols not found on CoinGecko get tier "unknown".
          Uses in-memory cache with TTL.
          """
          if self._is_cache_valid():
              return self._cache

          # Build reverse mapping
          coin_ids = []
          id_to_symbol: dict[str, str] = {}
          for symbol in symbols:
              cg_id = SYMBOL_TO_COINGECKO.get(symbol)
              if cg_id:
                  coin_ids.append(cg_id)
                  id_to_symbol[cg_id] = symbol

          # Fetch from CoinGecko
          market_caps = self._fetch_market_caps(coin_ids)

          result = {}
          for symbol in symbols:
              cg_id = SYMBOL_TO_COINGECKO.get(symbol)
              if cg_id and cg_id in market_caps:
                  mc = market_caps[cg_id]
                  result[symbol] = {
                      "tier": _classify_tier(mc),
                      "market_cap": str(mc),
                      "coingecko_id": cg_id,
                  }
              else:
                  result[symbol] = {
                      "tier": "unknown",
                      "market_cap": "0",
                      "coingecko_id": SYMBOL_TO_COINGECKO.get(symbol, ""),
                  }

          self._cache = result
          self._cache_time = time.time()

          logger.info(
              "market_cap_tiers_loaded",
              total=len(result),
              tiers={t: sum(1 for v in result.values() if v["tier"] == t) for t in ("mega", "large", "mid", "small", "unknown")},
          )

          return result
  ```

  **API endpoints** -- In `api.py`, add:

  1. `GET /api/pairs/{symbol}/distribution` -- calls `pair_analyzer.get_rate_distribution()`:
     ```python
     @router.get("/pairs/{symbol:path}/distribution")
     async def get_pair_distribution(
         request: Request, symbol: str, range: str = "all"
     ) -> JSONResponse:
         pair_analyzer = getattr(request.app.state, "pair_analyzer", None)
         if pair_analyzer is None:
             return JSONResponse(content={"error": "Pair analysis not available"}, status_code=501)
         since_ms = _range_to_since_ms(range)
         try:
             dist = await pair_analyzer.get_rate_distribution(symbol, since_ms=since_ms)
             return JSONResponse(content=dist)
         except Exception as e:
             return JSONResponse(content={"error": str(e)}, status_code=500)
     ```

  2. `POST /api/pairs/distributions` -- calls `pair_analyzer.get_multi_rate_distribution()` for box plot (accepts `{"symbols": [...]}` body):
     ```python
     @router.post("/pairs/distributions")
     async def get_multi_pair_distributions(request: Request) -> JSONResponse:
         pair_analyzer = getattr(request.app.state, "pair_analyzer", None)
         if pair_analyzer is None:
             return JSONResponse(content={"error": "Pair analysis not available"}, status_code=501)
         try:
             body = await request.json()
             symbols = body.get("symbols", [])
             range_str = body.get("range", "all")
             since_ms = _range_to_since_ms(range_str)
             dist = await pair_analyzer.get_multi_rate_distribution(symbols, since_ms=since_ms)
             return JSONResponse(content=dist)
         except Exception as e:
             return JSONResponse(content={"error": str(e)}, status_code=500)
     ```

  3. `GET /api/market-cap` -- calls `market_cap_service.get_pair_tiers()`:
     ```python
     @router.get("/market-cap")
     async def get_market_cap_tiers(request: Request) -> JSONResponse:
         market_cap_service = getattr(request.app.state, "market_cap_service", None)
         if market_cap_service is None:
             return JSONResponse(content={"error": "Market cap service not available"}, status_code=501)
         data_store = getattr(request.app.state, "data_store", None)
         if data_store is None:
             return JSONResponse(content={})
         pairs = await data_store.get_tracked_pairs(active_only=True)
         symbols = [p["symbol"] for p in pairs]
         tiers = market_cap_service.get_pair_tiers(symbols)
         return JSONResponse(content=tiers)
     ```

  **App wiring** -- In `src/bot/main.py` (or `src/bot/dashboard/app.py` if that's where app.state is set), wire the `MarketCapService` to `app.state.market_cap_service` during app initialization. Check the existing pattern for how `pair_analyzer` is wired. The `MarketCapService` needs no async init -- just instantiate it. Check for `COINGECKO_API_KEY` env var:

  ```python
  import os
  from bot.data.market_cap import MarketCapService

  # In app setup:
  app.state.market_cap_service = MarketCapService(
      api_key=os.environ.get("COINGECKO_API_KEY"),
  )
  ```
  </action>
  <verify>
  Run `python -c "from bot.analytics.pair_analyzer import PairAnalyzer; print('OK')"` to verify no import errors.
  Run `python -c "from bot.data.market_cap import MarketCapService; s = MarketCapService(); print('OK')"` to verify the service initializes.
  Run `python -c "from bot.dashboard.routes.api import router; print('OK')"` to verify API routes compile.
  </verify>
  <done>PairAnalyzer has get_rate_distribution() and get_multi_rate_distribution() methods. MarketCapService fetches and caches CoinGecko market cap tiers. Three new API endpoints serve distribution data and market cap tiers. MarketCapService wired to app.state.</done>
</task>

<task type="auto">
  <name>Task 2: Pairs page UI -- histogram, box plot, market cap filter, performance summary</name>
  <files>src/bot/dashboard/templates/pairs.html, src/bot/dashboard/templates/base.html</files>
  <action>
  **In `base.html`**, the boxplot CDN script needs to be loaded on pages that use it. Since `pairs.html` extends `base.html` and already has a `{% block head %}` that loads Chart.js, add the boxplot plugin CDN there. Do NOT modify base.html -- instead, add the script to the `{% block head %}` in `pairs.html` only, after Chart.js:

  ```html
  {% block head %}
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4"></script>
  <script src="https://cdn.jsdelivr.net/npm/@sgratzl/chartjs-chart-boxplot@4"></script>
  {% endblock %}
  ```

  **In `pairs.html`**, add the following UI sections and JS:

  1. **Market cap filter buttons** -- Add a row of tier filter buttons above the ranking table, next to the date range buttons:
     ```html
     <div class="flex items-center gap-2" id="tier-buttons">
       <span class="text-xs text-gray-500 mr-1">Tier:</span>
       <button data-tier="all" class="px-2 py-1 text-xs rounded bg-blue-600 text-white">All</button>
       <button data-tier="mega" class="px-2 py-1 text-xs rounded bg-dash-card text-gray-400 border border-dash-border hover:text-white">Mega</button>
       <button data-tier="large" class="px-2 py-1 text-xs rounded bg-dash-card text-gray-400 border border-dash-border hover:text-white">Large</button>
       <button data-tier="mid" class="px-2 py-1 text-xs rounded bg-dash-card text-gray-400 border border-dash-border hover:text-white">Mid</button>
       <button data-tier="small" class="px-2 py-1 text-xs rounded bg-dash-card text-gray-400 border border-dash-border hover:text-white">Small</button>
     </div>
     ```

  2. **Performance summary card** -- Add a summary card section (hidden until tier data loads):
     ```html
     <div id="tier-summary" class="hidden bg-dash-card rounded-lg border border-dash-border p-4">
       <h3 class="text-white font-semibold mb-2" id="tier-summary-title">Performance Summary</h3>
       <div id="tier-summary-cards" class="grid grid-cols-2 md:grid-cols-4 gap-4"></div>
     </div>
     ```

  3. **Rate distribution histogram** -- Add a histogram section in the pair-detail panel (after the chart container):
     ```html
     <div id="rate-histogram-container" class="hidden bg-dash-card rounded-lg border border-dash-border p-4">
       <h4 class="text-white font-semibold mb-2">Funding Rate Distribution</h4>
       <div style="position: relative; height: 250px;">
         <canvas id="rate-histogram-chart"></canvas>
       </div>
     </div>
     ```

  4. **Box plot comparison section** -- Add a section below the ranking table for cross-pair box plots:
     ```html
     <div id="boxplot-section" class="hidden space-y-3">
       <div class="flex items-center justify-between">
         <h3 class="text-lg font-semibold text-white">Rate Distribution Comparison</h3>
         <button id="close-boxplot" class="text-gray-400 hover:text-white text-sm px-3 py-1 rounded border border-dash-border hover:border-gray-500">Close</button>
       </div>
       <div class="flex items-center gap-3 mb-2">
         <span class="text-xs text-gray-400">Select pairs to compare:</span>
         <div id="boxplot-checkboxes" class="flex flex-wrap gap-2"></div>
         <button type="button" id="btn-render-boxplot" class="px-3 py-1 text-xs bg-blue-700 text-white rounded hover:bg-blue-600">Compare</button>
       </div>
       <div class="bg-dash-card rounded-lg border border-dash-border p-4">
         <div style="position: relative; height: 350px;">
           <canvas id="boxplot-chart"></canvas>
         </div>
       </div>
     </div>
     ```

  5. Add a "Compare Rates" button next to the "Close" button in the pair-detail section header that opens the boxplot section:
     ```html
     <button id="btn-open-boxplot" class="text-blue-400 hover:text-blue-300 text-sm px-3 py-1 rounded border border-dash-border hover:border-blue-500">Compare Rates</button>
     ```

  **In the `<script>` section of `pairs.html`**, add the following JS:

  1. State variables: `let tierData = {}; let currentTier = 'all'; let rankingData = [];`
  2. Fetch market cap tiers on page load:
     ```javascript
     fetch('/api/market-cap')
         .then(function(resp) { return resp.json(); })
         .then(function(data) {
             if (!data.error) tierData = data;
         })
         .catch(function() { /* degrade gracefully -- tier filtering disabled */ });
     ```
  3. Update `fetchRanking()` to store `rankingData` and apply tier filtering:
     - Store raw data in `rankingData` variable
     - After building rows, if `currentTier !== 'all'`, filter by `tierData[pair.symbol]?.tier === currentTier`
     - Show "Market Cap" column in table header if tierData is available
  4. Add tier filter button click handlers (same pattern as date range buttons).
  5. Add `renderTierSummary(filteredPairs)` function:
     - Computes: pair count, avg annualized yield, median yield, best/worst yield
     - Renders metric cards into `#tier-summary-cards`
     - Updates `#tier-summary-title` with tier name
     - Shows `#tier-summary` section
     - Shows text like "5 mega-cap pairs averaged 12.3% annualized yield after fees"
  6. Update `_showDetail()` to also fetch and render the rate distribution histogram:
     ```javascript
     fetch('/api/pairs/' + encodeURIComponent(symbol) + '/distribution?range=' + encodeURIComponent(currentRange))
         .then(function(resp) { return resp.json(); })
         .then(function(distData) {
             if (distData.bins && distData.bins.length > 0) {
                 renderRateHistogram(distData);
             } else {
                 document.getElementById('rate-histogram-container').classList.add('hidden');
             }
         });
     ```
  7. Add `renderRateHistogram(distData)` function:
     - Creates a Chart.js bar chart with `distData.bins` as labels and `distData.counts` as data
     - Uses blue bars (`rgba(59, 130, 246, 0.7)`)
     - Y-axis: "Count", X-axis: "Funding Rate"
     - Destroys previous chart if exists (same pattern as `renderFundingRateChart`)
  8. Add boxplot rendering:
     - "Compare Rates" button opens the boxplot section with checkboxes for all ranked pairs
     - Checkboxes are dynamically built from current `rankingData`
     - "Compare" button fetches `POST /api/pairs/distributions` with selected symbols
     - `renderBoxPlot(data)` creates a `type: 'boxplot'` chart:
       ```javascript
       function renderBoxPlot(data) {
           var ctx = document.getElementById('boxplot-chart').getContext('2d');
           if (window._boxplotChart) window._boxplotChart.destroy();

           var labels = Object.keys(data).map(function(s) { return s.split('/')[0]; });
           var rawData = Object.values(data).map(function(rates) {
               return rates.map(function(r) { return parseFloat(r); });
           });

           window._boxplotChart = new Chart(ctx, {
               type: 'boxplot',
               data: {
                   labels: labels,
                   datasets: [{
                       label: 'Funding Rate Distribution',
                       data: rawData,
                       backgroundColor: 'rgba(59, 130, 246, 0.5)',
                       borderColor: '#3b82f6',
                       borderWidth: 1,
                   }]
               },
               options: {
                   responsive: true,
                   maintainAspectRatio: false,
                   animation: { duration: 0 },
                   plugins: {
                       legend: { labels: { color: '#9ca3af' } }
                   },
                   scales: {
                       x: { ticks: { color: '#6b7280' }, grid: { color: '#334155' } },
                       y: {
                           ticks: {
                               color: '#6b7280',
                               callback: function(v) { return (v * 100).toFixed(4) + '%'; }
                           },
                           grid: { color: '#334155' },
                           title: { display: true, text: 'Funding Rate', color: '#9ca3af' }
                       }
                   }
               }
           });
       }
       ```
  9. Close boxplot button handler destroys chart and hides section.
  10. Close detail button handler also hides the rate histogram.
  </action>
  <verify>
  1. Visit `/pairs` and verify tier filter buttons appear (All, Mega, Large, Mid, Small).
  2. Click a pair to open detail -- verify a funding rate distribution histogram appears below the time series chart.
  3. Click "Compare Rates" button -- verify checkboxes appear for pair selection.
  4. Select 3-5 pairs and click "Compare" -- verify a box plot chart renders with correct labels.
  5. Filter by "Mega" tier -- verify only mega-cap pairs show and a performance summary card appears.
  6. Verify all existing pairs page functionality still works (ranking table, detail panel, date range filters).
  </verify>
  <done>
  Pairs page has: rate distribution histogram for individual pairs, cross-pair box plot comparison chart, market cap tier filter buttons, and performance summary card. CoinGecko data loads on page with graceful fallback. Box plot uses the CDN plugin with auto-computed quartiles.
  </done>
</task>

</tasks>

<verification>
1. `python -c "from bot.analytics.pair_analyzer import PairAnalyzer; from bot.data.market_cap import MarketCapService; print('OK')"` succeeds
2. GET /api/pairs/{symbol}/distribution returns histogram bins and raw rates
3. POST /api/pairs/distributions returns multi-pair raw rate arrays
4. GET /api/market-cap returns tier classifications for all tracked pairs
5. Pairs page shows rate histogram when viewing pair detail
6. Box plot chart renders with correct chart type when comparing pairs
7. Tier filter buttons filter the ranking table and show performance summary
8. All existing pairs page functionality preserved
</verification>

<success_criteria>
- get_rate_distribution() returns bins, counts, and raw_rates for any pair
- MarketCapService fetches CoinGecko data with in-memory caching (1h TTL)
- Tier filter buttons (mega, large, mid, small) filter the ranking table
- Performance summary card shows aggregate yield stats for selected tier
- Rate distribution histogram renders in pair detail panel
- Box plot chart renders with raw funding rate arrays using CDN plugin
- Graceful degradation when CoinGecko is unavailable (tier shows "unknown")
</success_criteria>

<output>
After completion, create `.planning/phases/10-strategy-builder-visualization/10-03-SUMMARY.md`
</output>
